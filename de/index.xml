<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CrowPi goes Java</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/</link><description>Recent content on CrowPi goes Java</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/index.xml" rel="self" type="application/rss+xml"/><item><title>Anforderungen</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/requirements/</guid><description>Benötigte Ausstattung CrowPi (Advanced Kit) Raspberry PI 3 Model B+ oder Raspberry PI 4 SD-Karte mit minimum 8 GB Speicherplatz Entwicklungsumgebung IntelliJ IDEA Version 2020.3 oder neuer Raspberry Pi Imager Netzwerk (Ethernet oder WLAN) Optionale Ausstattung Tastatur und Maus für Raspberry Pi</description></item><item><title>Die CrowPi Plattform</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/crowpi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/crowpi/</guid><description>Das Wichtigste in Kürze Beim CrowPi handelt es sich um einen vielfältigen Baukasten der Firma Elecrow, welcher in Verbindung mit einem Raspberry Pi den Benutzer zahlreiche Komponenten zu Lern- und Weiterbildungszwecken nutzen lässt. Das Gerät entstand im Rahmen einer Kickstarter-Kampagne und konnte schnell eine grosse Anzahl von Unterstützern finden.
Im Gegensatz zu anderen Elektronikbausätzen sind beim CrowPi alle Komponenten direkt über die Platine mit den jeweiligen Komponenten verbunden, so dass kein manuelles und aufwändiges Verkabeln der einzelnen Bauteile mehr erforderlich ist.</description></item><item><title>Raspberry PI Setup</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/raspberry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/raspberry/</guid><description>Installieren des Betriebssystems 1. Installieren des Raspberry Pi Imager Der offizielle Raspberry Pi Imager kann direkt auf der offiziellen raspberry.org Website in der aktuellsten Version heruntergeladen werden. Das einfache Tool funktioniert auf allen gängigen Betriebssystemen und kann mit wenigen Tastendrücken sehr simpel installiert werden. Genauere Anleitungen zur Installation sind ebenfalls auf der genannten Homepage verfügbar.
2. Herunterladen des FHNW CrowPi Image Das Image für den CrowPi welches das Betriebssystem für den Raspberry PI beinhaltet kann direkt aus dem Github Repository des CrowPi Projekts bezogen werden.</description></item><item><title>Starten der Applikation</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/running/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/running/</guid><description>In diesem Kapitel wird genauer beschrieben, was alles beim Starten einer Applikation passiert und wie das Framework benutzt werden kann. Der genaue Aufbau des Application Frameworks welches dies alles auf diese Art und Weise ermöglicht ist in einem einzelnen Kapitel zu finden.
Starten des Application Framework Grundsätzlich wurde ein erster Start bereits zum Test am Ende des Setups ausgeführt. Benötigt wurden folgende 3 Schritte:
Anwählen der Run Config crowpi-examples [install] Starten mit Run Button Wählen der Applikation auf der Kommandozeile (falls keine Argumente verwendet werden) Was passiert beim Start Durch die Startkonfiguration und das Maven Projekt werden automatisch verschiedene Schritte beim Starten der Applikation ausgeführt.</description></item><item><title>Debugging der Applikation</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/debugging/</guid><description>Auf dieser Seite werden die Grundlagen der Fehlersuche mit dem Setup aus dem ersten Kapitel beschrieben. Es wird Schritt für Schritt erklärt wie man den Debugger starten und verwenden kann.
Applikation mit Debugger starten Zum Starten der Applikation mit Debugger werden die beiden Run Konfigurationenen crowpi-examples [debug] und Remote Debug benötigt. Diese sind nach dem Setup bereits korrekt eingestellt und können verwendet werden. Wichtig dabei ist die Reihenfolge mit der die Konfigurationen gestartet werden.</description></item><item><title>IntelliJ IDEA Setup</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/intellij/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/intellij/</guid><description>Installieren von IntelliJ IDEA In diesem Tutorial wird die Entwicklung mit Hilfe der Entwicklungsumgebung IntelliJ IDEA umgesetzt. Entsprechend sind auch die Artikel, Anweisungen und Bilder jeweils damit erstellt. IntelliJ IDEA kann bei Jetbrains in verschiedenen Versionen bezogen werden. Für die Entwicklung mit dem CrowPi verfügt die Community Version bereits über genügend Funktionalität. Für Studenten der Fachhochschule Nordwestschweiz ist jedoch auch die Ultimate Version kostenfrei erhältlich. Die Entwicklungsumgebung ist sowohl für Windows, macOS und auch Linux verfügbar.</description></item><item><title>Application Framework</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/framework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/framework/</guid><description>Grundlagen Um ein möglichst einfaches Arbeiten mit diesem Projekt zu gewährleisten, wurde ein einfaches Application Framework definiert. Dieses besteht aus einem regulären Java Interface und schon mit wenigen Zeilen Code kann eine neue Applikation mit eigenem Code gebaut werden. An jede Applikation wird hierbei jeweils der Pi4J Context übergeben, mit welchem alle Komponenten des CrowPi angesteuert werden können.
Starten einer Applikation Der integrierte Launcher kann zu jeder Zeit mit Maven gestartet werden.</description></item><item><title>Entwicklungsprozess</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/dev-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/dev-process/</guid><description>Dieses Ablaufdiagramm zeigt wie eine Entwicklung einer neuen Applikation mit dem CrowPi Goes Java Framework ablaufen könnte.
graph TB; A[Idee] -- B B[Benötigte Hardware] -- C{Neue Entwicklung oder mit Beispiel} C -- | Beispiel erweitern | D[Passendes Example wählen] -- F C -- | Neue Anwendung | E[App erstellen und registrieren] -- F F[Lesen Dokumentation zu Hardware] -- G G[Ablauf aufzeichnen] -- H H[App programmieren] -- I I[Unit Tests ergänzen] -- H I -- J[Testen der App] J -- K[Dokumentation der App] Erklärung der einzelnen Schritte Idee Bevor eine Entwicklung nur ansatzweise denkbar ist, muss eine Idee vorhanden sein.</description></item><item><title>7-Segment Anzeige</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/seven-segment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/seven-segment/</guid><description>Funktionsweise Die 7-Segment Anzeige auf dem CrowPi besteht aus 4 verschiedenen Ziffern, welche jeweils die Werte 0-9 sowie A-F darstellen können. Der Name ist dabei auch Programm, da jede Ziffer grundsätzlich aus 7 verschiedenen Segmenten besteht, welche je nach Zustand (an/aus) dann die verschiedenen Werte darstellen können. Dies bedeutet jedoch auch dass bei der Anzeige auf dem CrowPi insgesamt 33 verschiedene Segmente existieren (4x 7-Segment, 4x Dezimalpunkt, 1x Doppelpunkt), welche alle einzeln angeschlossen und gesteuert werden müssten.</description></item><item><title>Button</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button/</guid><description>Funktionsweise Bei einem Button handelt es sich schlichtweg um einen ganz einfachen Knopf, welcher entweder gedrückt wird oder eben nicht. Auf dem CrowPi stehen neben der Button Matrix auch vier unabhängige Knöpfe zur Verfügung, welche mit den Richtungen Up (oben), Down (unten), Left (links), Right (right) bezeichnet sind.
Bei dieser Komponente wird schlichtweg der entsprechende GPIO-Pin direkt ausgelesen und ohne weitere Verarbeitung ausgewertet. Somit lässt sich diese sehr einfach verwenden und kann jedoch trotzdem für viele verschiedene Zwecke eingesetzt werden.</description></item><item><title>Button Matrix</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button-matrix/</guid><description>Funktionsweise Bei einer Button-Matrix handelt es sich um nichts anderes als ein Gitter von Knöpfen, also zum Beispiel 4 × 4 Knöpfe wie beim CrowPi. In der simpelsten Form könnte jeder Knopf einzeln mit einem GPIO Pin verbunden werden, jedoch stösst man auf diese Art und Weise schnell an die maximale Kapazität von GPIO Pins eines Raspberry Pi.
Eine andere Methode, welche auch von der Button-Matrix auf dem CrowPi genutzt wird, ist, dass die Kombination der beiden Achsen für das Auslesen der einzelnen Knöpfe verwendet wird.</description></item><item><title>Buzzer</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/buzzer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/buzzer/</guid><description>Funktionsweise Der Buzzer funktioniert wie ein Lautsprecher, jedoch mit dem Unterschied, dass dieser technisch gesehen nur einen einzigen Ton abspielen kann. Dank der Verwendung von PWM ist es jedoch möglich diesen auch so anzusteuern, dass damit entsprechende Melodien mit verschiedenen Tönen abgespielt werden können.
Die Klasse BuzzerComponent verwendet eine solche PWM-Implementation und bietet eine einfache Schnittstelle, mit welcher beliebige Töne abgespielt werden können. Um eine zuverlässige Wiedergabe der gewünschten Frequenzen zu ermöglichen, verwendet diese Komponente Hardware PWM.</description></item><item><title>I²C</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/i2c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/i2c/</guid><description>Das Wichtigste in Kürze I²C (gesprochen Englisch als I-Squared-C) ist ein ursprünglich von Philips erfundener Bus. Er ist als klassischer Master-Slave-Bus konzipiert. Wobei eine Datenübertragung immer durch einen Master initiiert wird. Auch ein Aufbau in einem Multi-Master System ist möglich. Angeschlossen wird I²C über zwei Signalleitungen (Datenleitung und Taktleitung). Die Übertragungsrate des Buses kann je nach Taktrate zwischen 0.1 Mbit/s bis zu 3.4 Mbit/s liegen. Sofern nur eine unidirektionale Verbindung nötig ist, wäre sogar 5.</description></item><item><title>LCD Display</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/lcd-display/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/lcd-display/</guid><description>Funktionsweise Beim LCD Display handelt es sich um eine der komplexesten Komponenten des CrowPi. Die betrifft sowohl die Ansteuerung in der Software als auch die Funktionalität des Displays an sich. Das LCD Display verfügt auf 2 Zeilen jeweils über 16 kleine Pixelfelder. Diese bestehen aus je 5x8 Pixeln. Jedes dieser Pixel wird von den Mikrocontrollern des Displays einzeln angesteuert um so Buchstaben, Zahlen und Sonderzeichen zu zeigen. Auf diese Weise können also bis zu 32 Zeichen gleichzeitig angezeigt werden.</description></item><item><title>LED Matrix</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/led-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/led-matrix/</guid><description>Funktionsweise Bei der LED Matrix handelt es sich um eine Anzeige, welche aus einem Gitter von LEDs besteht. Im konkreten Fall vom CrowPi steht eine quadratische 8 × 8 LED Matrix zur Verfügung, sodass insgesamt 64 individuelle LEDs gesteuert werden können. Damit können neben der statischen Anzeige von Buchstaben, Zahlen und Symbolen auch einfache Animationen realisiert werden.
Zur Ansteuerung der einzelnen LEDs wären individuell steuerbare Leitungen unpraktisch, weshalb der elektronische Baustein MAX7219 verwendet wird.</description></item><item><title>Lichtsensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/light-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/light-sensor/</guid><description>Funktionsweise Der Lichtsensor nutzt photoelektronische Effekte, um Lichteinstrahlung in ein elektrisches Signal zu wandeln. Dieses Signal kann mittels Elektronik so skaliert werden, dass ein Messwert in der Einheit Lux entsteht. Beim CrowPi wird dazu der Umgebungslichtsensor BH1750 verwendet. Dieser arbeitet mit einer Photodiode. Zusätzlich erlaubt der verwendete Sensor eine Konfiguration der Messgenauigkeit. Er kann mit 3 verschiedenen Auflösungen betrieben werden. Diese sind: 0.5 Lux, 1 Lux oder 4 Lux. Die Zeit, welche für eine Messung benötigt wird, schwankt dabei massiv.</description></item><item><title>PIR Motion Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/pir-motion-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/pir-motion-sensor/</guid><description>Funktionsweise Beim PIR Motion Sensor handelt es sich um einen Bewegungssensor welcher mit passivem Infrarot arbeitet. Diese Komponente benutzt einen pyroelektrischen Sensor, welcher Infrarot-Strahlung erkennen kann. Da jedes Lebewesen und Objekt abhängig von seiner jeweiligen Temperatur eine unterschiedliche Menge an Infrarot-Strahlen emittiert, ist der Sensor in der Lage diese zu erkennen.
Um nun jedoch nicht das Grundrauschen zu messen, sondern effektiv Bewegung zu erkennen, ist der Sensor in zwei Hälften aufgeteilt, welche sich gegenseitig bei Stillstand wieder aufheben.</description></item><item><title>Pulse Width Modulation (PWM)</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/pwm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/pwm/</guid><description>Das Wichtigste in Kürze Die Abkürzung PWM steht für Pulse Width Modulation und wird im Deutschen auch oft als Pulsbreitenmodulation oder Pulsweitenmodulation bezeichnet. Diese Technik wird unter anderem für die Steuerung von Servomotoren eingesetzt und findet beispielsweise auch Verwendung bei den Lüftern von einem regulären Computer.
Mit PWM ist es möglich, eine Komponente wie einen Motor nicht nur mehr rein binär zu steuern, sprich Aus (0% Leistung) oder An (100% Leistung), sondern diese fast beliebig zu steuern.</description></item><item><title>Relais</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/relay/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/relay/</guid><description>Funktionsweise Das Relais ist eine Komponente, welche es ermöglichen soll mit geringen Schaltströmen grosse Lasten zu schalten. So kann beispielsweise mit dem Raspberry Pi eine grosse Lampe geschaltet werden, ohne den Raspberry Pi zu beschädigen. Um eine Last zu verkabeln, stellt das Relais drei Anschlüsse zur Verfügung. Diese sind beim CrowPi mit ´NC, NO, COM´ beschriftet. Die Anschlüsse für die Ansteuerung durch den CrowPi sind wie auch bei den anderen Komponenten bereits fertig verkabelt.</description></item><item><title>RFID</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/rfid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/rfid/</guid><description>Funktionsweise Bei RFID, abgekürzt für Radio Frequency Identification, handelt es sich um eine Technologie, welche es ermöglicht automatisch und kontaktlos mit einer Karte entsprechende Informationen auszutauschen. Dies wird zum Beispiel bei weit bekannten NFC Tags verwendet, jedoch auch für Anwendungen wie das kontaktlose Zahlen per Kreditkarte.
Ein grosser Vorteil ist hierbei, dass die jeweiligen Karten/Tags, auch Transponder genannt, so klein wie ein Reiskorn sein können und keine eigene Stromversorgung benötigen. Im CrowPi ist die Komponente MFRC522 verbaut, welche ein hochfrequentes elektronisches Wechselfeld bei 13.</description></item><item><title>Serial Peripheral Interface (SPI)</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/spi/</guid><description>Das Wichtigste in Kürze Das Serial Peripheral Interface, abgekürzt SPI, ist ein Bus-System welches eine Kommunikation zwischen einem Hauptgerät (englisch als «Master» bezeichnet) und ein oder mehreren Nebengeräten (englisch als «Slave» bezeichnet) ermöglicht. Eine direkte Kommunikation zwischen allen Teilnehmern ist hierbei nicht möglich, viel mehr kann der Master jederzeit auswählen mit welchem Slave er Daten austauschen möchte.
Um nur einen Slave anzusprechen werden insgesamt 3 Signalleitungen benötigt, wovon zwei für die bidirektionale Datenübertragung und eine als Taktgeber für die serielle Übertragung genutzt wird.</description></item><item><title>Sound Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/sound-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/sound-sensor/</guid><description>Funktionsweise Ein Sound Sensor funktioniert mittels eines Mikrofons. Die vom Mikrofon in elektrische Signale umgewandelten akustischen Schwingungen werden gegen einen Schwellenwert verglichen. Sobald die elektrischen Signale in ihrer Stärke einen gewissen Schwellwert übersteigen wird am Sensor ein digitaler Ausgang geschaltet. Es wurde Lärm oder ein Geräusch erkannt.
Am CrowPi kann dieser Schwellwert mittels eines Potentiometers eingestellt werden. Am einfachsten geht das, wenn man auf das entsprechende LED bei den Status LEDS achtet und den entsprechenden Lärm verursacht welcher erkannt werden soll.</description></item><item><title>Tilt Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/tilt-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/tilt-sensor/</guid><description>Funktionsweise Ein Tilt Sensor, auf Deutsch Neigungs- oder Kippsensor, erkennt wenn dieser in eine bestimmte Richtung geneigt wird. Es existieren hier einige verschiedene Ausführungen, die Komponente auf dem CrowPi basiert jedoch auf einem SW-200D, welcher nur eine Richtung kennt und somit lediglich eine Neigung nach links (HIGH) oder rechts (LOW) erkennen kann.
Hierfür ist der silberne Draht auf der linken Seite der Komponente mit einer leitenden Innenhülle verbunden, in welcher sich zwei kleine Metallkugeln befinden.</description></item><item><title>Touch Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/touch-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/touch-sensor/</guid><description>Funktionsweise Der Berührungssensor funktioniert im Wesentlichen wie jeder andere Knopf auch. Der Unterschied liegt darin das der Berührungs- oder Touch Sensor nicht gedrückt werden muss. Es reicht schon eine leichte Berührung, um den Sensor auszulösen. Beim CrowPi ist dieser Sensor am GPIO Pin Nummer 17 angeschlossen. Dabei kennt der Sensor nur zwei Zustände. Er ist entweder gedrückt oder eben nicht. Dies entspricht im Programm einem HIGH oder LOW. Der Sensor erkennt die Berührung durch die Veränderung des elektrischen Widerstandes durch den Kontakt mit der Haut.</description></item><item><title>Ultraschall Distanzsensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ultrasonic-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ultrasonic-sensor/</guid><description>Funktionsweise Der Ultraschall Distanzsensor misst mithilfe eines akustischen Signals die Distanz zu Objekten. Der Ton liegt dabei im Ultraschallbereich und ist für den Menschen nicht hörbar. Um das Signal von Umgebungsgeräuschen unterscheiden zu können, wird nicht ein langer Ton, sondern kurze pulsierendes Töne ausgeben. Beim im CrowPi verbauten Modell HC-SR04 handelt es sich dabei 8 einzelne Impulse auf einer Frequenz von 40kHz. Wenn diese Töne nun auf ein Objekt treffen, werden sie reflektiert und zurück Richtung Sensor geworfen.</description></item><item><title>Vibrationsmotor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/vibration-motor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/vibration-motor/</guid><description>Funktionsweise Beim Vibrationsmotor handelt es sich um einen sehr kleinen Motor welcher über eine kleine Unwucht verfügt. Durch diesen Fehler im Rundlauf entsteht die gewünschte Vibration. Aufgrund des elektrischen Anschlusses beim CrowPi ist jedoch nur ein Ein- und Ausschalten des Motors möglich. Theoretisch wäre aber auch PWM denkbar. Jedoch verfügt der verwendete Pin über keine PWM Funktionalität.
Voraussetzungen DIP Switches Für diese Komponente muss einer der DIP-Switches auf die folgende Position eingestellt werden:</description></item></channel></rss>