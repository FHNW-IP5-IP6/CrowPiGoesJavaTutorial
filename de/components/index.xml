<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Komponenten on CrowPi goes Java</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/</link><description>Recent content in Komponenten on CrowPi goes Java</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/index.xml" rel="self" type="application/rss+xml"/><item><title>7-Segment Anzeige</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/seven-segment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/seven-segment/</guid><description>Funktionsweise Die 7-Segment Anzeige auf dem CrowPi besteht aus 4 verschiedenen Ziffern, welche jeweils die Werte 0-9 sowie A-F darstellen können. Der Name ist dabei auch Programm, da jede Ziffer grundsätzlich aus 7 verschiedenen Segmenten besteht, welche je nach Zustand (an/aus) dann die verschiedenen Werte darstellen können. Dies bedeutet jedoch auch dass bei der Anzeige auf dem CrowPi insgesamt 33 verschiedene Segmente existieren (4x 7-Segment, 4x Dezimalpunkt, 1x Doppelpunkt), welche alle einzeln angeschlossen und gesteuert werden müssten.</description></item><item><title>Button</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button/</guid><description>Funktionsweise Bei einem Button handelt es sich schlichtweg um einen ganz einfachen Knopf, welcher entweder gedrückt wird oder eben nicht. Auf dem CrowPi stehen neben der Button Matrix auch vier unabhängige Knöpfe zur Verfügung, welche mit den Richtungen Up (oben), Down (unten), Left (links), Right (right) bezeichnet sind.
Bei dieser Komponente wird schlichtweg der entsprechende GPIO-Pin direkt ausgelesen und ohne weitere Verarbeitung ausgewertet. Somit lässt sich diese sehr einfach verwenden und kann jedoch trotzdem für viele verschiedene Zwecke eingesetzt werden.</description></item><item><title>Button Matrix</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button-matrix/</guid><description>Funktionsweise Bei einer Button-Matrix handelt es sich um nichts anderes als ein Gitter von Knöpfen, also zum Beispiel 4 × 4 Knöpfe wie beim CrowPi. In der simpelsten Form könnte jeder Knopf einzeln mit einem GPIO Pin verbunden werden, jedoch stösst man auf diese Art und Weise schnell an die maximale Kapazität von GPIO Pins eines Raspberry Pi.
Eine andere Methode, welche auch von der Button-Matrix auf dem CrowPi genutzt wird, ist, dass die Kombination der beiden Achsen für das Auslesen der einzelnen Knöpfe verwendet wird.</description></item><item><title>Buzzer</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/buzzer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/buzzer/</guid><description>Funktionsweise Der Buzzer funktioniert wie ein Lautsprecher, jedoch mit dem Unterschied, dass dieser technisch gesehen nur einen einzigen Ton abspielen kann. Dank der Verwendung von PWM ist es jedoch möglich diesen auch so anzusteuern, dass damit entsprechende Melodien mit verschiedenen Tönen abgespielt werden können.
Die Klasse BuzzerComponent verwendet eine solche PWM-Implementation und bietet eine einfache Schnittstelle, mit welcher beliebige Töne abgespielt werden können. Um eine zuverlässige Wiedergabe der gewünschten Frequenzen zu ermöglichen, verwendet diese Komponente Hardware PWM.</description></item><item><title>LCD Display</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/lcd-display/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/lcd-display/</guid><description>Funktionsweise Beim LCD Display handelt es sich um eine der komplexesten Komponenten des CrowPi. Die betrifft sowohl die Ansteuerung in der Software als auch die Funktionalität des Displays an sich. Das LCD Display verfügt auf 2 Zeilen jeweils über 16 kleine Pixelfelder. Diese bestehen aus je 5x8 Pixeln. Jedes dieser Pixel wird von den Mikrocontrollern des Displays einzeln angesteuert um so Buchstaben, Zahlen und Sonderzeichen zu zeigen. Auf diese Weise können also bis zu 32 Zeichen gleichzeitig angezeigt werden.</description></item><item><title>LED Matrix</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/led-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/led-matrix/</guid><description>Funktionsweise Bei der LED Matrix handelt es sich um eine Anzeige, welche aus einem Gitter von LEDs besteht. Im konkreten Fall vom CrowPi steht eine quadratische 8 × 8 LED Matrix zur Verfügung, sodass insgesamt 64 individuelle LEDs gesteuert werden können. Damit können neben der statischen Anzeige von Buchstaben, Zahlen und Symbolen auch einfache Animationen realisiert werden.
Zur Ansteuerung der einzelnen LEDs wären individuell steuerbare Leitungen unpraktisch, weshalb der elektronische Baustein MAX7219 verwendet wird.</description></item><item><title>Lichtsensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/light-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/light-sensor/</guid><description>Funktionsweise Der Lichtsensor nutzt photoelektronische Effekte, um Lichteinstrahlung in ein elektrisches Signal zu wandeln. Dieses Signal kann mittels Elektronik so skaliert werden, dass ein Messwert in der Einheit Lux entsteht. Beim CrowPi wird dazu der Umgebungslichtsensor BH1750 verwendet. Dieser arbeitet mit einer Photodiode. Zusätzlich erlaubt der verwendete Sensor eine Konfiguration der Messgenauigkeit. Er kann mit 3 verschiedenen Auflösungen betrieben werden. Diese sind: 0.5 Lux, 1 Lux oder 4 Lux. Die Zeit, welche für eine Messung benötigt wird, schwankt dabei massiv.</description></item><item><title>PIR Motion Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/pir-motion-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/pir-motion-sensor/</guid><description>Funktionsweise Beim PIR Motion Sensor handelt es sich um einen Bewegungssensor welcher mit passivem Infrarot arbeitet. Diese Komponente benutzt einen pyroelektrischen Sensor, welcher Infrarot-Strahlung erkennen kann. Da jedes Lebewesen und Objekt abhängig von seiner jeweiligen Temperatur eine unterschiedliche Menge an Infrarot-Strahlen emittiert, ist der Sensor in der Lage diese zu erkennen.
Um nun jedoch nicht das Grundrauschen zu messen, sondern effektiv Bewegung zu erkennen, ist der Sensor in zwei Hälften aufgeteilt, welche sich gegenseitig bei Stillstand wieder aufheben.</description></item><item><title>Relais</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/relay/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/relay/</guid><description>Funktionsweise Das Relais ist eine Komponente, welche es ermöglichen soll mit geringen Schaltströmen grosse Lasten zu schalten. So kann beispielsweise mit dem Raspberry Pi eine grosse Lampe geschaltet werden, ohne den Raspberry Pi zu beschädigen. Um eine Last zu verkabeln, stellt das Relais drei Anschlüsse zur Verfügung. Diese sind beim CrowPi mit ´NC, NO, COM´ beschriftet. Die Anschlüsse für die Ansteuerung durch den CrowPi sind wie auch bei den anderen Komponenten bereits fertig verkabelt.</description></item><item><title>RFID</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/rfid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/rfid/</guid><description>Funktionsweise Bei RFID, abgekürzt für Radio Frequency Identification, handelt es sich um eine Technologie, welche es ermöglicht automatisch und kontaktlos mit einer Karte entsprechende Informationen auszutauschen. Dies wird zum Beispiel bei weit bekannten NFC Tags verwendet, jedoch auch für Anwendungen wie das kontaktlose Zahlen per Kreditkarte.
Ein grosser Vorteil ist hierbei, dass die jeweiligen Karten/Tags, auch Transponder genannt, so klein wie ein Reiskorn sein können und keine eigene Stromversorgung benötigen. Im CrowPi ist die Komponente MFRC522 verbaut, welche ein hochfrequentes elektronisches Wechselfeld bei 13.</description></item><item><title>Sound Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/sound-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/sound-sensor/</guid><description>Funktionsweise Ein Sound Sensor funktioniert mittels eines Mikrofons. Die vom Mikrofon in elektrische Signale umgewandelten akustischen Schwingungen werden gegen einen Schwellenwert verglichen. Sobald die elektrischen Signale in ihrer Stärke einen gewissen Schwellwert übersteigen wird am Sensor ein digitaler Ausgang geschaltet. Es wurde Lärm oder ein Geräusch erkannt.
Am CrowPi kann dieser Schwellwert mittels eines Potentiometers eingestellt werden. Am einfachsten geht das, wenn man auf das entsprechende LED bei den Status LEDS achtet und den entsprechenden Lärm verursacht welcher erkannt werden soll.</description></item><item><title>Tilt Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/tilt-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/tilt-sensor/</guid><description>Funktionsweise Ein Tilt Sensor, auf Deutsch Neigungs- oder Kippsensor, erkennt wenn dieser in eine bestimmte Richtung geneigt wird. Es existieren hier einige verschiedene Ausführungen, die Komponente auf dem CrowPi basiert jedoch auf einem SW-200D, welcher nur eine Richtung kennt und somit lediglich eine Neigung nach links (HIGH) oder rechts (LOW) erkennen kann.
Hierfür ist der silberne Draht auf der linken Seite der Komponente mit einer leitenden Innenhülle verbunden, in welcher sich zwei kleine Metallkugeln befinden.</description></item><item><title>Touch Sensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/touch-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/touch-sensor/</guid><description>Funktionsweise Der Berührungssensor funktioniert im Wesentlichen wie jeder andere Knopf auch. Der Unterschied liegt darin das der Berührungs- oder Touch Sensor nicht gedrückt werden muss. Es reicht schon eine leichte Berührung, um den Sensor auszulösen. Beim CrowPi ist dieser Sensor am GPIO Pin Nummer 17 angeschlossen. Dabei kennt der Sensor nur zwei Zustände. Er ist entweder gedrückt oder eben nicht. Dies entspricht im Programm einem HIGH oder LOW. Der Sensor erkennt die Berührung durch die Veränderung des elektrischen Widerstandes durch den Kontakt mit der Haut.</description></item><item><title>Ultraschall Distanzsensor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ultrasonic-sensor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ultrasonic-sensor/</guid><description>Funktionsweise Der Ultraschall Distanzsensor misst mithilfe eines akustischen Signals die Distanz zu Objekten. Der Ton liegt dabei im Ultraschallbereich und ist für den Menschen nicht hörbar. Um das Signal von Umgebungsgeräuschen unterscheiden zu können, wird nicht ein langer Ton, sondern kurze pulsierendes Töne ausgeben. Beim im CrowPi verbauten Modell HC-SR04 handelt es sich dabei 8 einzelne Impulse auf einer Frequenz von 40kHz. Wenn diese Töne nun auf ein Objekt treffen, werden sie reflektiert und zurück Richtung Sensor geworfen.</description></item><item><title>Vibrationsmotor</title><link>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/vibration-motor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/vibration-motor/</guid><description>Funktionsweise Beim Vibrationsmotor handelt es sich um einen sehr kleinen Motor welcher über eine kleine Unwucht verfügt. Durch diesen Fehler im Rundlauf entsteht die gewünschte Vibration. Aufgrund des elektrischen Anschlusses beim CrowPi ist jedoch nur ein Ein- und Ausschalten des Motors möglich. Theoretisch wäre aber auch PWM denkbar. Jedoch verfügt der verwendete Pin über keine PWM Funktionalität.
Voraussetzungen DIP Switches Für diese Komponente muss einer der DIP-Switches auf die folgende Position eingestellt werden:</description></item></channel></rss>