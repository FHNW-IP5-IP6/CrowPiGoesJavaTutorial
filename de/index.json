[{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/requirements/","title":"Anforderungen","tags":[],"description":"","content":"Benötigte Ausstattung CrowPi (Advanced Kit) Raspberry PI 3 Model B+ oder Raspberry PI 4 SD-Karte mit minimum 8 GB Speicherplatz Entwicklungsumgebung IntelliJ IDEA Version 2023.2 oder neuer Raspberry Pi Imager Netzwerk (Ethernet oder WLAN) Optionale Ausstattung Tastatur und Maus für Raspberry Pi "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/crowpi/","title":"Die CrowPi Plattform","tags":[],"description":"","content":"Das Wichtigste in Kürze Beim CrowPi handelt es sich um einen vielfältigen Baukasten der Firma Elecrow, der in Verbindung mit einem Raspberry Pi den Benutzer zahlreiche Komponenten zu Lern- und Weiterbildungszwecken nutzen lässt. Das Gerät entstand im Rahmen einer Kickstarter-Kampagne und konnte schnell eine grosse Anzahl von Unterstützern finden.\nIm Gegensatz zu anderen Elektronikbausätzen sind beim CrowPi alle Komponenten direkt über die Platine mit den jeweiligen Komponenten verbunden, sodass kein manuelles und aufwendiges Verkabeln der einzelnen Bauteile mehr erforderlich ist. Stattdessen kann einfach ein Raspberry Pi eingesetzt werden, der sofort über seine GPIO Pins (General-Purpose Input/Output) die jeweiligen Aktoren und Sensoren ansprechen kann.\nDank dem integrierten Display des CrowPi sowie der mitgelieferten Tastatur und Maus ist es sogar möglich, direkt auf dem entsprechenden Gerät zu entwickeln oder andere grafische Applikationen darauf auszuführen. Da der Bildschirm für längeres Arbeiten etwas klein ist, wird im Tutorial eine Variante gewählt, bei der auf einem separaten PC oder Laptop entwickelt werden kann.\nBesonderheiten DIP Switches Aufgrund der hohen Anzahl an verschiedenen Komponenten stösst der CrowPi an eine Limitation des Raspberry Pi, konkret die Anzahl der verfügbaren GPIO Pins. Es ist nur möglich eine begrenzte Anzahl von Bauteilen mit dem Raspberry Pi zu verbinden bevor alle Ein- und Ausgänge belegt sind. Um dieses Problem zu umgehen, verwendet der CrowPi sogenannte DIP Switches:\nEs handelt sich hierbei um die beiden rot umrandeten Schaltergruppen, die jeweils 8 kleine Schalter anbieten. In der Standardposition sind diese alle ausgeschaltet und somit in der unteren Position, womit sich die meisten Komponenten vom CrowPi direkt einsetzen lassen. Bei manchen Komponenten müssen aber noch einzelne Schalter eingeschaltet (= obere Position) werden, um eine andere verbundene Komponente vom Raspberry Pi abzuhängen und stattdessen die neue Komponente anzusprechen.\nMan kann sich diese Schalter beim CrowPi somit als eine Art Weiche vorstellen, die entweder die eine oder die andere Komponente mit dem Raspberry Pi verbindet. In diesem Tutorial wird jeweils auf die benötigte Schalterposition hingewiesen. Es lässt sich so zwar eine Vielzahl von Komponenten verbinden, aber einige Konfigurationen sind wegen dieser Limitation nicht möglich.\nKomponenten Der CrowPi verfügt über eine grosse Anzahl von Sensoren und Aktoren, die über die jeweiligen Pins auf dem Raspberry Pi mittels Pi4J angesprochen werden können. Es kommen hierbei unterschiedliche Protokolle und Schnittstellen zum Einsatz, die von den entsprechenden Komponenten-Klassen dieses Tutorials abstrahiert und vereinfacht werden. Nachfolgend sind alle vorhandenen Komponenten aufgeführt:\nKomponente Einsatzzweck Schnittstelle Position von DIP Switches 7-Segment Anzeige Anzeigen von bis zu 4 Ziffern I²C ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Button Abfragen von vier unabhängigen Knöpfen GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Button Matrix Abfragen von Matrix aus 4 × 4 Knöpfen GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Buzzer Abspielen von verschiedenen Tönen PWM ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Infrarot Empfänger Empfangen von Infrarot-Signalen GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 LCD Display Anzeige von Text und Zahlen I²C, GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 LED Matrix Darstellen von beliebigen Symbolen SPI ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Lichtsensor Erkennen von aktueller Lichtstärke I²C ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 PIR Motion Sensor Erkennen von Bewegung mit passivem Infrarot GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Relais Schaltung eines elektrischen Kontakts GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 RFID Kontaktloses Lesen und Schreiben von Karten SPI ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Schrittmotor Bewegen eines Schrittmotors GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Servomotor Bewegen eines Servomotors PWM ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Sound Sensor Erkennen von Lärm oder Stille GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Temperatur- und Luftfeuchtigkeitssensor Messen von Temperatur und Luftfeuchtigkeit GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Tilt Sensor Erkennt aktuelle Neigung (links/rechts) von CrowPi GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Touch Sensor Erkennen von Berührungen GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Ultraschall Distanz Sensor Messung von Distanzen mit Ultraschall GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Vibrationsmotor Erzeugen eines Vibrationsalarms GPIO ON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Weitere Ressourcen Offizielle Anleitung von Hersteller (Englisch) Ursprüngliche Kickstarter-Kampagne für CrowPi (Englisch) "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/","title":"Vorbereitungen","tags":[],"description":"","content":"Kapitel 1 Vorbereitungen In diesem Kapitel wird das erste Einrichten des CrowPi sowie die Entwicklungsumgebung schrittweise beschrieben. Beginnend beim Installieren des Betriebssystems für den CrowPi auf einem Raspberry Pi bis hin zur perfekten Vorbereitung der Entwicklungsergebung für eine möglichst komfortable und effiziente Softwareentwicklung.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/","title":"Grundlagen","tags":[],"description":"","content":"Kapitel 2 Grundlagen Hier sind die Grundlagen bezüglich CrowPi goes Java.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/raspberry/","title":"Raspberry PI Setup","tags":[],"description":"","content":"Installieren des Betriebssystems 1. Installieren des Raspberry Pi Imager Der offizielle Raspberry Pi Imager kann direkt auf der raspberry.org Website in der aktuellsten Version heruntergeladen werden. Das einfache Tool funktioniert auf allen gängigen Betriebssystemen und kann mit wenigen Tastendrücken installiert werden. Genauere Anleitungen zur Installation sind ebenfalls auf der genannten Homepage verfügbar.\n2. Herunterladen des Pi4J-CrowPi-OS Image Das Image für den CrowPi, welches das Betriebssystem für den Raspberry Pi beinhaltet, kann direkt aus dem Github Repository des Pi4J Projekts bezogen werden, das auch noch weitere spezialisierte Images bereitstellt.\nDas neueste Release des Betriebssystems für den CrowPi findet ihr unter diesem Link: Download CrowPi Image\nNach dem Download das .zip Archiv entpacken. Schon ist alles bereit für den nächsten Schritt.\n3. Schreiben des Images auf eine SD Karte Beim Schreiben des Images auf die SD-Karte werden sämtliche Daten, welche sich noch darauf befinden, überschrieben!\nAls Erstes muss die SD-Karte auf dem Computer als Laufwerk verfügbar sein. Dazu gibt es verschiedene Möglichkeiten. Es eignen sich Kartenlesegeräte genauso wie auch USB Adapter.\nNun wird das Tool Raspberry Pi Imager gestartet. Als Erstes muss das Betriebssystem gewählt werden. Dazu den Knopf OS WÄHLEN drücken. Nun findet sich ganz unten in der Auswahl Eigenes Image. Im Auswahldialog das vorher heruntergeladene und entpackte Pi4J-CrowPi-OS.img auswählen. Als zweiter Schritt wird nun die SD-Karte ausgewählt. Dazu im Menu den Knopf SD-KARTE WÄHLEN drücken. Es zeigt einem automatisch nur verfügbare Wechselmedien wie USB-Sticks oder SD-Karten. Dabei ist es jetzt sehr wichtig den korrekten Eintrag auszuwählen, um ungewollten Datenverlust zu vermeiden. Auf Windows wird unter dem Datenträger jeweils noch angezeigt, welcher Laufwerksbuchstabe effektiv betroffen ist, sodass dieser einfach im Explorer überprüft werden kann. Im Zweifelsfall aber einfach Datenträger mit wichtigen Medien vorher ausstecken, sodass sicher nichts passieren kann.\nÜber den Preferences-Knopf muss nun noch ein neuer Benutzer angelegt werden.\nBenutzername: pi Passwort: pi4j Schon ist alles bereit um das Image auf die SD-Karte zu schreiben. Der Vorgang kann durch Betätigen vom SCHREIBEN Knopf ausgelöst werden. Es folgt nochmals ein Bestätigungsdialog, bevor dann endgültig sämtlicher Inhalt der SD-Karte überschrieben wird. Das Schreiben des Image auf die SD-Karte kann einige Minuten dauern. Das ist völlig normal. Sobald der Vorgang abgeschlossen ist, kommt die entsprechende Meldung. Die SD-Karte kann nun aus dem Computer entfernt werden.\n4. Einsetzen der SD Karte in den Raspberry Pi Zum Einsetzen der vorbereiteten SD-Karte in den CrowPi müssen die 4 Halteschrauben gelöst werden. Diese finden sich hier: Nach dem Lösen der Schrauben kann der Raspberry Pi angehoben werden. Allenfalls müssen noch einige Kabel ausgesteckt werden. Auf der Unterseite findet sich nun der SD-Karten Einschub. Hier kann die SD-Karte mit den Kontaktflächen gegen den Raspberry Pi eingesetzt werden. Auf dem Bild unten ist nochmals der Einschub markiert. Sobald die SD-Karte eingesetzt ist, kann der Raspberry Pi wieder korrekt in den CrowPi eingebaut und die gelösten Kabel wieder eingesteckt werden. Sobald alles wieder an seinem Platz ist, kann der CrowPi mit dem Strom verbunden werden.\nBevor der CrowPi nun in Betrieb genommen wird, sollte noch einmal überprüft werden, ob alle 3 Kabel mit dem Raspberry Pi verbunden sind. Es sollte sowohl der HDMI-Adapter auf der linken Seite, das USB-Kabel auf der unteren Seite sowie das GPIO Flachbandkabel auf der rechten Seite verbunden sein. Diese zwingend erforderlichen Kabel sind in der nächsten Grafik mit roten Kreisen umrahmt.\nOptional kann noch eine Tastatur und Maus per USB verbunden werden, was nachfolgend mit einem pinken Kreis markiert wurde:\nNun kann der CrowPi eingeschaltet werden, worauf dieser nach einer kurzen Initialisierungszeit zur Verfügung steht. Die Zugangsdaten für den CrowPi sind pi als Benutzername und pi4j als Passwort, welche nicht geändert werden sollten da ansonsten die mitgelieferten IntelliJ-Konfigurationen nicht mehr direkt lauffähig sind.\n5. Herstellen der Netzwerkverbindung Einzig die Netzwerkverbindung des frisch gestarteten Raspberry Pi muss noch manuell getätigt werden. Ansonsten sind alle Einstellungen bereits optimal im Pi4J-CrowPi-OS Image enthalten. Nun gibt es für die Netzwerkverbindung einige Möglichkeiten:\nVerbindung per WLAN (empfohlen für FHNW) Verbindung per Ethernetkabel (DHCP) Verbindung per Ethernetkabel direkt zu Computer Am einfachsten lassen sich die Einstellungen mittels am Raspberry Pi angeschlossener Maus und Tastatur vollziehen. Die Einrichtung via WLAN wird explizit empfohlen, da sich diese in fast jeder Umgebung nutzen lässt und mittels Hotspot-Funktion am eigenen Smartphone auch unterwegs prima funktioniert.\nNachfolgend wird nur die Verbindung per WLAN beschrieben, jedoch kann bei vorhandener Expertise in diesem Gebiet auch eine Verbindung via Kabel aufgebaut werden.\n5.1 Herstellen einer WLAN Verbindung Der Raspberry Pi und der Laptop müssen in der Regel mit dem gleichen WLAN verbunden sein.\nVerwenden des Pi4J-Spot Auf dem Pi4J-CrowPi-OS Image ist eine WLAN-Verbindung voreingestellt.\nssid: Pi4J-Spot password: MayTheSourceBeWithYou! Sobald ein dementsprechender Hotspot, zum Beispiel auf einem Smartphone, angelegt wird, verbindet sich der CrowPi mit diesem Hotspot und die aktuelle IP-Adresse des CrowPi wird als Hintergrundbild angezeigt.\nDann noch den Laptop ebenfalls mit Pi4J-Spot verbinden.\nEinstellen der WLAN-Verbindung auf dem CrowPi Um mit einem WLAN Netzwerk zu verbinden, auf dem Desktop des CrowPi oben rechts das Icon mit den beiden Pfeile klicken und das gewünschte WLAN auswählen.\nAnschliessend im Dialog das entsprechende WLAN Passwort bei gesicherten Verbindungen eintippen. Einige Sekunden nach der Verbindung wird sich das Hintergrundbild des CrowPi automatisch aktualisieren und die zugewiesene IP-Adresse anzeigen. Auf den Bildern ist zusätzlich auch eine Ethernet Adresse sichtbar. Das heisst es war im Moment der Aufnahme zusätzlich noch ein Ethernetkabel verbunden mit dem Raspberry Pi.\nNachdem wir nun eine Netzwerkverbindung zum CrowPi haben, sind wir bereit für das Einrichten der Entwicklungsumgebung als nächsten Schritt.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/running/","title":"Starten der Applikation","tags":[],"description":"","content":"In diesem Kapitel wird genauer beschrieben, was alles beim Starten einer Applikation passiert und wie das Framework benutzt werden kann. Der genaue Aufbau des Application Frameworks welches dies alles auf diese Art und Weise ermöglicht, ist in einem separaten Kapitel zu finden.\nStarten des Application Framework Grundsätzlich wurde ein erster Start bereits zum Test am Ende des Setups ausgeführt. Benötigt wurden folgende 3 Schritte:\nAnwählen der Run Config Run on CrowPi Starten mit Run Button Wählen der Applikation auf der Kommandozeile (falls keine Argumente verwendet werden) Was passiert beim Start Durch die Startkonfiguration und das Maven Projekt werden automatisch verschiedene Schritte beim Starten der Applikation ausgeführt. Grundsätzlich folgt der Ablauf immer diesem Schema: graph TB; A[Resolve Dependencies] --\u003e B B[Compile Java Code] --\u003e C C[Run Unit Tests] --\u003e D D[Copy Code to Raspberry Pi] --\u003e E E[Start Application] Bei jedem Start werden also sogar die Unit tests ausgeführt. So kann eine optimale Codequalität beim Entwickeln erreicht werden.\nStart mit Argument Der Start mit einem Argument soll es ermöglichen direkt eine der Applikationen auszuwählen, ohne die Nummer in der Kommandozeile eintippen zu müssen. Dazu muss die Run Konfiguration angepasst werden. Dies funktioniert sowohl für Run on CrowPi als auch für Debug on CrowPi genau gleich.\nDas Kontextmenü bei der Run Konfiguration Edit Configurations ... öffnen. Nun bei der gewünschten Konfiguration den Tab Runner öffnen und mit dem + ein neues Argument hinzufügen. Gewählt werden muss das crowpi.laucher.args und als Wert wird der exakte Name einer Applikation wie zum Beispiel BuzzerApp eingetragen. Normales Starten der Applikation mit dem Play Button Jetzt startet der übliche Ablauf. Anstelle der Auswahl einer ExampleApp wird jedoch direkt die angegebene Applikation gestartet, also in diesem Fall die BuzzerApp.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/debugging/","title":"Debugging der Applikation","tags":[],"description":"","content":"Auf dieser Seite werden die Grundlagen der Fehlersuche mit dem Setup aus dem ersten Kapitel beschrieben. Dazu wird Schritt für Schritt erklärt, wie man den Debugger starten und verwenden kann.\nApplikation mit Debugger starten Zum Starten der Applikation mit Debugger werden die beiden Run Konfigurationen Debug on CrowPi und Attach to CrowPi Debugger benötigt.\nDiese sind nach dem Setup bereits korrekt eingestellt und können verwendet werden. Wichtig dabei ist die Reihenfolge, mit der die Konfigurationen gestartet werden. Dieses Vorgehen ist:\nStart von Debug on CrowPi mit dem Run-Knopf (nicht mit dem Debug-Knopf) Warten bis die Konsolenausgabe meldet Listening for transport dt_socket at address: 5005 (Attach debugger) Starten von Attach to CrowPi Debugger Nachfolgend wird der Ablauf mit entsprechenden Abbildungen ergänzt. Als Erstes wird die Applikation im Debugmodus gestartet. Dazu muss die Konfiguration Debug on CrowPi angewählt werden. Gestartet wird die Konfiguration mit dem Play Button. Als Zweites wird nun gewartet, bis die korrekte Ausgabe im Konsolenfenster erscheint: Zum Starten des Remote Debugger die entsprechende Run Konfiguration Attach to CrowPi Debugger auswählen und mit einem Klick auf das Käfer-Icon (Debug) starten. Das Debugfenster meldet nun, ob eine Verbindung hergestellt wurde. Nun kann zwischen den beiden Tabs Run und Debug hin und her gewechselt werden.\nIm Tab Run wird die Ausgabe der Applikation angezeigt. Bei Debug finden sich Knöpfe und Informationen zu Breakpoints und Variablen. Wenn nun ein Beispiel ausgeführt wird, startet dies ganz normal und läuft, bis das Programm beendet wird. Solange keine Breakpoints oder ähnliches im Programmablauf vorkommen, hat der Debugger keinen weiteren Einfluss auf die Applikation.\nEinsatz von Breakpoints Wenn nun ein Problem auftritt, wird oft an der entsprechenden Codestelle ein Breakpoint gesetzt. Dieser Breakpoint weist den Debugger an, die laufende Applikation zu unterbrechen und den aktuellen Programmstatus auf dieser Zeile im Code auszugeben. An der Beispielapplikation 7-Segment Anzeige wird demonstriert, wie ein Breakpoint verwendet werden kann. Untersucht soll die Anzeige der - - - - werden. Wie im Beispielcode ersichtlich passiert dies mit einem for-loop.\nSetzen des Breakpoints an Codestelle Ein Breakpoint kann in IntelliJ sehr einfach durch Klicken neben die Zeilennummer in einem Programm eingefügt werden. Platziert wird der Breakpoint hier bewusst vor den zu untersuchenden for-loop. So kann sichergestellt werden, dass nichts verpasst wird. Wenn nicht genau bekannt ist, wo ein Problem verursacht wird, lohnt es sich fast immer den Breakpoint ein paar Zeilen über der kritischen Stelle zu platzieren. So kann die Ausgangslage gut analysiert werden. Starten der Applikation mit Debugger Wie vorgängig erklärt, wird zuerst der Breakpoint platziert, die Applikation im Debugmodus gestartet und der Debugger angehängt. Es werden also diese 3 Schritte durchgeführt:\nStart von Debug on CrowPi ohne Verwendung vom Debug-Knopf Warten bis die Konsolenausgabe meldet Listening for transport dt_socket at address: 5005 (Attach debugger) Starten von Attach to CrowPi Debugger Da ein Fehler im 7-Segment Beispiel gesucht werden soll, wird das entsprechende Beispielprogramm nach Programmstart angewählt. Die Applikation wird ausgeführt, bis der Debugger am Breakpoint die Ausführung der Anwendung unterbricht. Nachfolgend die Ansicht in IntelliJ, wenn der Debugger das Programm unterbrochen hat. IntelliJ markiert die entsprechende aktuelle Zeile im Programm. Im Debug-Tab werden zudem die aktuellen Variablen mit Werten der Applikation ausgegeben. Navigation am Breakpoint Um nun die Programmausführung schrittweise fortzusetzen, verfügt die Entwicklungsumgebung über verschiedene Funktionen. Diese beinhalten Grundfunktionen wie das Fortsetzen der Applikation oder das komplette Stoppen der Applikation. Die wichtigsten kurz erklärt:\nResume Program setzt das Programm fort bis zum nächsten Breakpoint oder Applikationsende Stop Remote Debug stoppt den Debugger. Da in diesem Setup jedoch die Applikation und der Debugger getrennt laufen, hat die Option keinen sinnvollen Effekt. Zum Stoppen des Programms sollte immer Stop All verwendet werden. Dies wird auf dem zweiten Bild gezeigt. Mute Breakpoints / Disable all Breakpoints der Debugger deaktiviert alle Breakpoints. So wird das Programm bei weiterer Ausführung nicht mehr unterbrochen. Für die schrittweise Ausführung des Programms stellt der Debugger noch weitere Tasten zur Verfügung:\nStep Over die nächste Anweisung im Code wird ausgeführt. Bei einem Methodenaufruf wird der Rückgabewert ermittelt, ohne die Methode zu betreten. Step Into die nächste Anweisung im Code wird ausgeführt. Bei einem Methodenaufruf wird der Code der Methode geöffnet und das Debugging geht in der Methode weiter. Force Step Into die nächste Anweisung im Code wird ausgeführt. Bei einem Methodenaufruf, welcher normalerweise bei Step Into ignoriert, wird das Eintauchen in die Methode erzwungen. Step Out die aktuelle Methode wird ausgeführt, bis der Code wieder am aufrufenden Ort angekommen ist. Wird zum vorzeitigen Rückkehren aus Step Into verwendet. Noch genauere Erklärungen zu den einzelnen Funktionen können auch direkt der IntelliJ Anleitung entnommen werden.\nAnalyse von Variablen Inzwischen wurden einige Steps an der Codestelle des for-loops ausgeführt. Nun nochmals ein Blick auf die Variablenliste des Debuggers.\nAuf dem Bild kann erkannt werden, wie der Debugger dem Benutzer anzeigt welche Variablen nun welche Werte haben. Aktuell ist es also: i=2 und state=\u0026quot;- \u0026quot;\nDa der for-loop erst bei i \u0026gt; 5 stoppt, könnte nun mit dem Debugger jede weitere Iteration nachvollzogen werden. Auf diese Weise lassen sich auch Entscheidungen bei if (this) {then that} else {other things} nachvollziehen. Jede Variable kann auf ihren Zustand geprüft und somit bei Fehlentscheiden die Logik angepasst werden.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/jdk/","title":"JDK Setup","tags":[],"description":"","content":"Installation auf dem Entwickler-Laptop Im Pi4J-CrowPi-OS Image ist Java in der Version 17 (das sogenannte JDK) bereits vorinstalliert. Daher verwenden wir diesen JDK auch auf dem Laptop. Download: Java 17\nHinweis für Mac-Benutzer: Die Verwendung von SDKMAN (s.u.) für die Installation und die Verwaltung von JDKs ist sehr empfehlenswert.\nEmpfehlung zur Installation des JDK für MacOS (und Linux) Für MacOs und Linux gibt es ein sehr empfehlenswertes Tool zur Verwaltung unterschiedlicher Software Development Kits: SDKMAN\nInsbesondere wenn, wie üblich, mehrere Java JDKs verwendet werden, hilft SDKMAN.\nInstallation von SDKMAN Folgenden Befehl in einem Terminal eingeben:\nexport SDKMAN_DIR=\u0026#34;$HOME/sdkman\u0026#34; \u0026amp;\u0026amp; curl -s \u0026#34;https://get.sdkman.io\u0026#34; | bash Falls Sie SDKMAN bereits früher installiert haben, müssen Sie SDKMAN auf den neuesten Stand bringen:\nsdk update Installation des JDK In einem neuen Terminal-Window diesen Befehl eingeben:\nsdk install java 17.0.8-tem Danach liegt der JDK in ihrer Home-Directory im Folder sdkman/candidates/java. Von dort können Sie es dann in IntelliJ als neues SDK anlegen und im Projekt verwenden.\nMit:\nsdk ls java kann man sich auflisten lassen, welche anderen JDKs zur Installation zur Verfügung stehen.\nJava Version überprüfen In einem Terminal-Window eingeben\njava -version Das sollte diese Ausgabe erzeugen\nopenjdk version \u0026#34;17.0.8\u0026#34; 2023-07-18 OpenJDK Runtime Environment Temurin-17.0.8+7 (build 17.0.8+7) OpenJDK 64-Bit Server VM Temurin-17.0.8+7 (build 17.0.8+7, mixed mode) Falls das nicht der Fall ist, muss der Default-JDK umgestellt werden. Mit SDKMAN geht das einfach:\nsdk default java 17.0.8-tem "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/","title":"Komponenten","tags":[],"description":"","content":"Kapitel 3 Komponenten Der CrowPi verfügt über eine besonders grosse Anzahl von Sensoren und Aktoren, um allerlei Projekte zu ermöglichen und der Kreativität freien Lauf zu lassen. Die nachfolgenden Unterseiten beziehen sich jeweils auf eine bestimmte Komponente und vermitteln neben einem Beispiel auch, wie diese funktionieren und wie sich diese Komponenten verwenden lassen.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/framework/","title":"Application Framework","tags":[],"description":"","content":"Grundlagen Um ein möglichst einfaches Arbeiten mit diesem Projekt zu gewährleisten, wurde ein einfaches Application Framework definiert. Dieses besteht aus einem regulären Java Interface und somit kann schon mit wenigen Zeilen Code eine neue Applikation mit eigenem Code gebaut werden.\nAn jede Applikation wird hierbei jeweils der Pi4J Context übergeben, mit welchem alle Komponenten des CrowPi angesteuert werden können.\nStarten einer Applikation Der integrierte Launcher kann zu jeder Zeit mit Maven gestartet werden. Falls der Code direkt auf dem Raspberry Pi zur Verfügung steht, kann zum Beispiel mit folgenden Befehlen eine Applikation gestartet werden:\n# Führt den Launcher ohne Angabe einer Applikation aus, worauf ein Auswahlmenü erscheint. # Nach Selektion der gewünschten Applikation wird diese schliesslich gestartet. mvn install # Führt direkt eine bestimmte Applikation mit dem Launcher aus ohne Umweg über das Auswahlmenü. # Im Beispiel wird direkt die \u0026#34;BuzzerApp\u0026#34; gestartet. mvn install -Dcrowpi.launcher.args=BuzzerApp Neue Applikation anlegen Um eine neue Applikation anzulegen, welche anschliessend über den integrierten Launcher gestartet werden kann, sind nur wenige Schritte erforderlich. Die nachfolgende Anleitung führt Schritt für Schritt zur ersten eigenen Applikation.\nZuerst muss eine Java-Klasse unterhalb von src/main/java/com/pi4j/crowpi/applications erstellt werden mit einem beliebigen Namen, welche das Interface Application implementiert. Zum Beispiel könnte diese Klasse ExampleApp heissen und folgenden Code enthalten:\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/ExampleApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; public class ExampleApp implements Application { @Override public void execute(Context pi4j) { System.out.println(\u0026#34;CrowPi with Pi4J rocks!\u0026#34;); } } Anschliessend muss die Applikation nur noch in der Klasse com.pi4j.crowpi.Launcher zur Liste APPLICATIONS hinzugefügt werden. Die Datei ist unter src/main/java/com/pi4j/crowpi/Launcher.java aufzufinden und muss an dieser Stelle erweitert werden:\npublic final class Launcher implements Runnable { // ... private static final List\u0026lt;Application\u0026gt; APPLICATIONS = new ArrayList\u0026lt;\u0026gt;(Arrays.asList( new ExampleApp(), // hier wird die neue Applikation eingefügt new BuzzerApp() )); // ... } Nun kann diese neue Applikation beliebig erweitert werden, indem weitere Codes innerhalb der execute() Methode hinzugefügt werden. Die Applikation kann jederzeit durch Starten des Launchers getestet werden und erscheint automatisch in der Auswahlliste.\nOptional ist es auch möglich, den Namen oder die Beschreibung der Applikation selber anzupassen. Es ist hierbei wichtig, dass der Name unter allen eingehängten Applikationen jeweils eindeutig ist. Um diese Änderungen durchzuführen, können diese Methoden in der eigenen Applikationsklasse verwendet werden:\npublic class ExampleApp implements Application { // ... @Override public String getName() { return \u0026#34;CoolApp\u0026#34;; } @Override public String getDescription() { return \u0026#34;Meine coole Applikation\u0026#34;; } // ... } Der Name entspricht hierbei auch dem Parameter, der an den Launcher übergeben werden muss, um die Applikation direkt zu starten. Im Normalfall ist es aber aufgrund potenzieller Namenskonflikte nicht empfohlen, diesen zu überschreiben.\nDas Interface Zur Vollständigkeit ist hier noch das komplette Application Interface eingebunden. Dieses besteht aus exakt drei Methoden, wobei hiervon nur execute() implementiert werden muss, da die anderen Methoden bereits über eine Standardimplementation verfügen.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/Application.java Auf GitHub ansehen package com.pi4j.crowpi; import com.pi4j.context.Context; /** * This interface should be implemented by each CrowPi example / application */ public interface Application { /** * Represents the main application entrypoint called by the launcher. * This should execute whatever the application is supposed to do. * * @param pi4j Pi4J context */ void execute(Context pi4j); /** * Returns a unique name which is used to determine how the application can be called. * This uses the simple class name by default, so that the application has the same name as its class. * * @return Unique application name */ default String getName() { return this.getClass().getSimpleName(); } /** * Returns a human-readable description what this application is doing. * This returns a short explanation together with the class FQDN by default. * * @return Human-readable application description */ default String getDescription() { return this.getClass().getName(); } /** * Utility function to sleep for the specified amount of milliseconds. * An {@link InterruptedException} will be catched and ignored while setting the interrupt flag again. * * @param milliseconds Time in milliseconds to sleep */ default void sleep(long milliseconds) { try { Thread.sleep(milliseconds); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/","title":"Hardware","tags":[],"description":"","content":"Kapitel 4 Hardware Die verschiedenen Komponenten des CrowPi werden über eine Vielzahl von Schnittstellen angebunden. In diesem Kapitel wird auf die technischen Details eingegangen, sodass ein tieferes Verständnis der dahinterliegenden Technik erworben werden kann.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/setup/intellij/","title":"IntelliJ IDEA Setup","tags":[],"description":"","content":"Installieren von IntelliJ IDEA In diesem Tutorial wird die Entwicklung mit Hilfe der Entwicklungsumgebung IntelliJ IDEA umgesetzt. Entsprechend sind auch die Artikel, Anweisungen und Bilder jeweils damit erstellt. IntelliJ IDEA kann bei Jetbrains in verschiedenen Versionen bezogen werden.\nFür die Entwicklung mit dem CrowPi verfügt die Community Version bereits über genügend Funktionalität. Für Studierende der Fachhochschule Nordwestschweiz ist jedoch die Ultimate Version empfehlenswert, die ebenfalls kostenfrei erhältlich ist. Die Entwicklungsumgebung ist sowohl für Windows, macOS als auch Linux verfügbar. Der Download findet sich hier: Download IntelliJ IDEA. Das anschliessende Einrichten von IntelliJ IDEA verhält sich ebenfalls auf allen Plattformen identisch.\nSehr empfehlenswert ist die Installation via die Toolbox App.\n1. Klonen des Repository Sobald wir nun die Entwicklungsumgebung installiert haben geht es an das Klonen des Einstiegsprojekts für den CrowPi. Dabei findet sich der Sourcecode auf GitHub. Um das Repository zu klonen, muss auf GitHub der entsprechende Link kopiert werden und dann in IntelliJ IDEA importiert werden. Dazu schrittweise in Bildern eine etwas genauere Anleitung.\nUm Konflikte mit dem offiziellen Repository zu vermeiden, ist es jedoch am besten seine eigene Kopie zu erstellen. Besuche hierfür zuerst das CrowPi Repository auf GitHub und klicke auf den angezeigten Knopf Use this template um dein eigenes Repository mit dem gleichen Inhalt zu erhalten:\nNun erscheint eine neue Seite, wo ein beliebiger Name für das eigene Repository vergeben werden muss. Die weiteren Optionen können nach Belieben angepasst werden, sind jedoch nicht erforderlich. Mit einem Klick auf Create repository for this template wird nun eine Kopie vom Repository erzeugt:\nNach einer kurzen Ladezeit steht das eigene Repository anschliessend zur Verfügung. Nun ist auf den angezeigten grünen Knopf Code zu klicken, um den Link zum eigenen Repository zu erhalten, welcher im nächsten Schritt im IntelliJ angegeben wird:\n2. Importieren des Projekts Im Startfenster von IntelliJ ist die Option Get from VCS verfügbar. Diese muss angewählt werden damit direkt aus GitHub der Code geklont werden kann. Danach kann einfach der Link, welcher zuvor bei GitHub kopiert wurde, eingefügt werden. Durch die Bestätigung mitClone wird der Vorgang gestartet und eine allenfalls nötige Authentifizierung des Benutzers wird ausgeführt. Dabei einfach den Anweisungen des Tools folgen. Sobald das Projekt vollständig auf den lokalen Computer geklont wurde, öffnet sich automatisch das Projekt in der Entwicklungsumgebung. Dabei poppt unten rechts ein kleiner Dialog auf. Dieser muss mit Import bestätigt werden damit das Repository richtig initialisiert werden kann.\nMaven ist ein Softwareprojektmanagement Tool. Näheres dazu kann direkt beim Apache Maven Project nachgelesen werden. Grundsätzlich muss daran jedoch nichts verändert werden. Das CrowPi Projekt bietet bereits ein vollständiges Setup und kann einfach benutzt werden. Das Importieren des Maven Projekts löst jeweils eine Sicherheitswarnung bei IntelliJ aus. Diese kann einfach mit Trust project ... bestätigt werden, solange der Code aus dem offiziellen FHNW CrowPi Repository stammt. Nun noch der letzte Import Schritt. Damit später besser Fehler gesucht werden können und auch die Funktionen der Komponenten ganz tief analysiert werden können, lohnt es sich bei Maven Documentations and Sources herunterzuladen. Das geht leicht mit einigen Klicks. Ganz rechts wird das Maven Projekt Menu geöffnet. Anschliessend durch einen Klick auf Download Sources and/or Documentation. Im Kontextmenü dann anschliessend Download Sources and Documentation wählen. So sind alle verwendeten Libraries lokal verfügbar und einsehbar.\nNun fehlt nur noch die Startkonfiguration des Projekts welche in der nächsten Sektion beschrieben ist. 3. Einstellung der Run Konfiguration Das Projekt CrowPi der FHNW benutzt vier Run Konfigurationen. In diesen ist definiert welche Teile des Codes auf welche Art und Weise ausgeführt werden. Verwendet werden die Konfigurationen:\nRun on CrowPi Run on CrowPi(Demo Mode) Debug on CrowPi Attach to CrowPi Debugger Dabei kopiert Run on CrowPi den aktuellen Code auf den Raspberry Pi. Dies funktioniert über eine Kombination aus SSH/SCP. Anschliessend wird der kopierte Code auf dem Raspberry Pi gestartet.\nDebug on CrowPi macht im Prinzip nichts anderes. Jedoch werden andere Optionen bei der Verbindung ausgewählt und vor der eigentlichen Ausführung der Applikation wird auf eine Verbindung von einem Debugger gewartet.\nAttach to CrowPi Debugger stellt genau diesen Debugger zur Verfügung. Dieser verbindet sich mit dem Raspberry Pi und die Fehlersuche kann beginnen. Näheres findet man hier: Starten und Debuggen auf dem CrowPi\nZusätzlich existiert auch noch eine Konfiguration Run on CrowPi(Demo Mode), welche genau gleich wie CrowPi Run funktioniert und zusätzlich den Parameter --demo übergibt. Dies bewirkt, dass der Launcher sich nach Ausführung einer Applikation nicht mehr selber beendet, sondern mehrere Beispiele nacheinander ausgeführt werden können. Wie der Name schon sagt, ist dies besonders für Demozwecke praktisch.\n4. Erster Testlauf Schon ist es geschafft. Alles ist eingerichtet, um ein erstes Mal das CrowPi Projekt direkt aus der Entwicklungsumgebung zu starten.\nDazu die Run Konfiguration CrowPi Run auswählen. Danach durch Drücken von dem grünen Play Button die Applikation starten. Es öffnet sich das Run Fenster von IntelliJ. Es dauert einen Moment und einiges an Text wird auf der Kommandozeile ausgegeben. Nach einigen Sekunden stoppt die Ausgabe und es sieht wie folgt aus: Hier kann nun eine Zahl entsprechend der Anweisung eingetippt werden und mit Enter bestätigt werden. Die entsprechende Beispielapplikation wird dann ausgeführt. Sollten dabei jetzt noch Fehlermeldungen in der Kommandozeile auftreten lohnt es sich nochmals die Netzwerkverbindung des Computers und des Raspberry Pi zu überprüfen. Auch in der Troubleshooting Sektion dieses Tutorials sind noch einige Tipps und Tricks zur Fehlerbehebung zu finden.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/dev-process/","title":"Entwicklungsprozess","tags":[],"description":"","content":"Dieses Ablaufdiagramm zeigt, wie die Entwicklung einer neuen Applikation mit dem CrowPi Goes Java Framework ablaufen könnte.\ngraph TB; A[Idee] --\u003e B B[Benötigte Hardware] --\u003e C{Neue Entwicklung oder mit Beispiel} C --\u003e | Beispiel erweitern | D[Passendes Example wählen] --\u003e F C --\u003e | Neue Anwendung | E[App erstellen und registrieren] --\u003e F F[Lesen Dokumentation zu Hardware] --\u003e G G[Ablauf aufzeichnen] --\u003e H H[App programmieren] --\u003e I I[Unit Tests ergänzen] --\u003e H I --\u003e J[Testen der App] J --\u003e K[Dokumentation der App] Erklärung der einzelnen Schritte Idee Bevor auch nur im Ansatz an eine Entwicklung zu denken ist, muss eine Idee vorhanden sein. Der Kreativität sind keine Grenzen gesetzt.\nJedoch sollten besonders Anfänger beachten, dass erste Anwendungen nicht zu kompliziert gestaltet werden. Umso wichtiger ist eine saubere Umsetzung.\nBenötigte Hardware Um sich einen Überblick zu verschaffen, sollte die Hardware, die zur Umsetzung der eigenen Idee benötigt wird, kurz umrissen werden.\nNeue Entwicklung oder mit Beispiel Wenn sich die Idee stark an einem der vorgegebenen Beispiele orientiert, ist es womöglich einfacher und schneller das Beispiel auszubauen und anzupassen. Vielleicht möchte man aber auch gerne auf der grünen Wiese mit dem Bauen starten. Dann wählt man eher die Variante einer komplett neuen Applikation im Rahmen von CrowPi Goes Java.\nPassendes Example Auswählen Wenn die Entscheidung gefällt wurde, auf einem Beispiel aufzubauen, wählt man das entsprechende Beispiel aus. Dies erspart uns die Schritte, welche bei einer neuen Applikation nötig wären.\nApp erstellen und registrieren Gemäss Anleitung im Application Framework wird eine neue Applikation erstellt.\nLesen der Dokumentation zur Hardware Um genauer zu erfahren, wie benötigte Hardware funktioniert, lohnt es sich die entsprechenden Kapitel hier im Tutorial zu betrachten.\nSo erfährt man welche Funktionen bereits zur Verfügung stehen und wo allenfalls noch Lücken vorhanden sind. Auch versteht man die physikalischen Vorgänge im Hintergrund etwas besser.\nAblauf aufzeichnen Programmieren ohne Plan endet meist in einem unstrukturierten, chaotischen Code. Es ist also sinnvoll sich erst einen Schlachtplan zurechtzulegen. Sehr effizient und hilfreich sind dabei insbesondere Ablauf- oder Statusdiagramme.\nApp Programmieren Entspricht der Abbildung der benötigten Funktion in Form von Code.\nUnit Tests ergänzen Eine gute Applikation wird immer automatisch getestet. Unit Tests stellen dabei eine einfache aber effektive Möglichkeit dar. Es besteht sogar das Konzept des Test-Code-Refactor, wo vor dem eigentlichen Code erst die Tests programmiert werden. So kann auch bei nachträglichen Änderungen sichergestellt werden, dass die ursprünglichen Funktionen erhalten bleiben.\nTesten der App Obwohl die Testabdeckung mit Unit Tests sehr zur Qualität beiträgt, handelt es sich bei CrowPi um ein Gerät mit Hardwarekomponenten. Das rein virtuelle Testen wird also nie jeden Fall abdecken können. Ein gründliches Testen mit der Hardware durch einen oder mehrere Benutzer ist immer von Vorteil.\nDokumentation der App Zur späteren Nachvollziehbarkeit des Codes hilft eine kurzgehaltene aber vollständige Dokumentation der erstellen Applikation enorm.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/basics/troubleshooting/","title":"Troubleshooting","tags":[],"description":"","content":"Fehlerhafte PiGPIO Initialisierung Sollte beim Ausführen einer Applikation via Launcher eine Fehlermeldung erscheinen, dass PiGpio nicht initialisiert werden kann, so sind entweder nicht ausreichend Rechte vorhanden oder es läuft bereits eine andere Java-Applikation welche PiGPIO blockiert. Da mit dem CrowPi Image und den beigelegten Run Konfigurationen die Rechte automatisch korrekt vergeben werden, handelt es sich im Normalfall um das zweite Problem. Die Fehlerausgabe auf der Konsole sieht in etwa so aus:\n[main] WARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed java.lang.reflect.UndeclaredThrowableException at jdk.proxy2/com.sun.proxy.jdk.proxy2.$Proxy6.create(Unknown Source) at com.pi4j@2.0-SNAPSHOT/com.pi4j.context.Context.create(Context.java:325) at com.pi4j@2.0-SNAPSHOT/com.pi4j.internal.IOCreator.create(IOCreator.java:58) ... Neben einem Geräteneustart, welcher das Problem in jedem Fall beseitigen wird, lässt sich auch über das Terminal der nachfolgende Befehl ausführen, welcher alle Java-Prozesse auf dem System beendet: sudo killall -9 java\nAnschliessend sollte es wieder möglich sein, Applikationen auf dem CrowPi zu starten. Sollte diese Alternative nicht zum Erfolg führen und weiterhin ein Fehler auftreten, so ist das Gerät stattdessen aus- und wieder einzuschalten. Hierbei ist zu beachten, dass das Gerät komplett stromlos gemacht werden sollte, da ein normaler Reboot nicht alle Komponenten zurücksetzt.\nÜberprüfung von I²C Bus Um schnell zu überprüfen, ob der I²C Bus ordnungsgemäss initialisiert wurde und alle Geräte zur Verfügung stehen, lässt sich am einfachsten der Befehl i2cdetect -y 1 via Terminal ausführen:\nDie Ausgabe des Befehls sollte bei Ausführung auf einem CrowPi 1 die drei Adressen 21, 5c und 70 auflisten. Auf anderen Gerätetypen oder einer neuen Hardwarerevision des CrowPi kann die Ausgabe entsprechend abweichen.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/seven-segment/","title":"7-Segment Anzeige","tags":["i2c"],"description":"","content":"Funktionsweise Die 7-Segment Anzeige auf dem CrowPi besteht aus 4 verschiedenen Ziffern, welche jeweils die Werte 0-9 sowie A-F darstellen können. Der Name ist dabei auch Programm, da jede Ziffer grundsätzlich aus 7 verschiedenen Segmenten besteht, welche je nach Zustand (an/aus) dann die verschiedenen Werte darstellen können. Dies bedeutet jedoch auch, dass bei der Anzeige auf dem CrowPi insgesamt 33 verschiedene Segmente existieren (4x 7-Segment, 4x Dezimalpunkt, 1x Doppelpunkt), welche alle einzeln angeschlossen und gesteuert werden müssten.\nUm dies zu vermeiden, verwendet die 7-Segment Anzeige den HT16K33, einen elektronischen Baustein zur Ansteuerung von mehreren LEDs über eine einzelne Schnittstelle. Hierfür wird der Bus I2C eingesetzt, über welchen verschiedene Steuerungsbefehle an die 7-Segment Anzeige gesendet werden können.\nDa das Übertragen jeder einzelnen Änderung an die Komponente sehr ineffizient ist, wird üblicherweise ein Buffer in der Software implementiert. Alle gewünschten Anpassungen verändern somit nur den Buffer, welcher anschliessend mit nur einem einzigen Befehl übertragen werden kann. Dieses Prinzip wird auch von der Komponenten-Klasse SevenSegmentComponent verwendet.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.SevenSegmentComponent Javadoc beschrieben. Es ist hierbei wichtig zu beachten, dass alle Methoden mit dem Wort \u0026ldquo;Buffer:\u0026rdquo; am Anfang der Beschreibung nicht eine direkte Auswirkung haben, sondern erst mit einem Aufruf von void refresh() auf der Anzeige sichtbar werden. Es ist somit zu empfehlen, alle gewünschten Einstellungen zu tätigen und dann mit einem einzigen Aufruf die Änderungen auf dem Gerät darzustellen.\nKonstruktoren Konstruktor Bemerkung SevenSegmentComponent(com.pi4j.context.Context pi4j) Initialisiert eine 7-Segment Anzeige mit der Standard Bus- und Geräteadresse für den CrowPi. SevenSegmentComponent(com.pi4j.context.Context pi4j, int bus, int device) Initialisiert eine 7-Segment Anzeige mit einer benutzerdefinierten Bus- und Geräteadresse. Methoden Methode Bemerkung void print(int i) Gibt eine Ganzzahl mit bis zu 4 Ziffern auf der Anzeige aus. Zu lange Zahlen werden nach hinten abgeschnitten. void print(double d) Gibt eine Kommazahl mit bis zu 4 Ziffern auf der Anzeige aus. Zu lange Zahlen werden nach hinten abgeschnitten. void print(java.time.LocalTime time) Gibt die übergebene Uhrzeit in Stunden und Minuten auf der Anzeige aus. Der Doppelpunkt auf der Anzeige wird bei ungerader Sekundenzahl aktiviert und ansonsten deaktiviert. void print(String s) Gibt die ersten 4 übergebenen Zeichen auf der Anzeige aus. Hierbei ist zu beachten dass die Anzeige nur wenige Zeichen unterstützt und ansonsten eine IllegalArgumentException wirft. void clear() Löscht den internen Buffer ohne die Anzeige zu aktualisieren. void refresh() Aktualisiert die Anzeige mit dem aktuellen Inhalt des Buffers. void setEnabled(boolean enabled) Schaltet die Anzeige ein oder aus gemäss Boolean-Wert. void setBlinkRate(int rate) Setzt die gewünschte Blink-Geschwindigkeit der ganzen Anzeige zwischen 0 (aus) und 3 (am schnellsten). void setBrightness(int brightness) Setzt die gewünschte Helligkeit der ganzen Anzeige zwischen 0 (am dunkelsten) und 15 (am hellsten). void setColon(boolean enabled) Buffer: Aktiviert/deaktiviert den Doppelpunkt auf der Anzeige. void setDecimalPoint(int position, boolean enabled) Buffer: Aktiviert/deaktiviert den entsprechenden Dezimalpunkt auf der Anzeige. Diese Einstellung wird durch Setzen einer Ziffer automatisch wieder deaktiviert. void setDigit(int position, int i) Buffer: Setzt die entsprechende Ziffer auf die übergebene Zahl zwischen 0 und 9. void setDigit(int position, char c) Buffer: Setzt die entsprechende Ziffer auf das übergebene Zeichen. void setDigit(int position, Segment... segments) Buffer: Setzt bei der entsprechenden Ziffer die übergebenen Segmente. Beispielapplikation Die nachfolgende Beispielapplikation besteht aus 3 verschiedenen Sektionen, welche die Vielfältigkeit der 7-Segment Anzeige veranschaulichen sollen. Zuerst werden die 4 Ziffern auf der Anzeige auf verschiedene Werte gesetzt, wobei es sich bei der letzten Ziffer sogar um ein komplett eigenes Symbol handelt.\nNach einer Wartezeit von 3 Sekunden wird eine kleine Ladeanimation auf der Anzeige dargestellt. Hierfür wird ein Array states definiert, in welchem die Ladeposition mithilfe von Zeichenketten dargestellt wird. Es handelt sich hierbei um einen Strich, welcher sich jeweils von links nach rechts bewegt. Hierfür wird eine verschachtelte for-Schleife eingesetzt, wobei mit i die ganze Animation insgesamt fünfmal wiederholt wird, während die innere Schleife über alle möglichen Animationszustände iteriert und diese nacheinander mit einer Verzögerung von 50 Millisekunden ausgibt.\nNachdem diese Ladeanimation abgespielt wurde, geht die Applikation in eine Schleife für 15 Sekunden und stellt jeweils die aktuelle Uhrzeit dar. Die API-Methode print(LocalTime time) übernimmt hierbei den Grossteil der Arbeit und blinkt sogar automatisch wenn die Sekundenzahl zurzeit ungerade ist. Nach 15 Sekunden schaltet sich die Anzeige aus und die Applikation endet.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/SevenSegmentApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.SevenSegmentComponent; import com.pi4j.crowpi.components.SevenSegmentComponent.Segment; import java.time.LocalTime; /** * Shows some basic digits and a fake loading indicator before acting as a clock which displays the time on the CrowPi for 15 seconds. * The colon on the seven-segment display will blink for every odd second. */ public class SevenSegmentApp implements Application { @Override public void execute(Context pi4j) { // Initialize and enable seven-segment display component final var segment = new SevenSegmentComponent(pi4j); segment.setEnabled(true); // Activate full brightness and disable blinking // These are the defaults and just here for demonstration purposes segment.setBlinkRate(0); segment.setBrightness(15); // Manually set some digits and symbols to demonstrate the advanced API segment.setDigit(0, \u0026#39;1\u0026#39;); // Place the character \u0026#34;1\u0026#34; into the first digit segment.setDecimalPoint(0, true); // Activate the decimal point after the first digit segment.setDigit(1, \u0026#39;a\u0026#39;); // Place the character \u0026#34;a\u0026#34; into the second digit segment.setDigit(2, 4); // Place the number 4 into the third digit segment.setDigit(3, Segment.TOP, Segment.BOTTOM); // Activate top and bottom segment for fourth digit segment.refresh(); // Send updated buffer to display // Sleep for three seconds before moving on... sleep(3000); // Show fake loading indicator by moving a single dash from left to right several times // We do so by initializing an array with all possible states (forward \u0026amp; reverse) and printing it in order final var states = new String[]{\u0026#34;- \u0026#34;, \u0026#34; - \u0026#34;, \u0026#34; - \u0026#34;, \u0026#34; -\u0026#34;, \u0026#34; - \u0026#34;, \u0026#34; - \u0026#34;, \u0026#34;- \u0026#34;}; for (int i = 0; i \u0026lt; 5; i++) { for (String state : states) { // Print current state and sleep for 50 milliseconds segment.print(state); sleep(50); } } // Loop for 15 seconds and print the current time every second for (int i = 0; i \u0026lt; 15; i++) { // Print current local time segment.print(LocalTime.now()); // Sleep for one second before continuing sleep(1000); } // Disable the seven-segment display segment.setEnabled(false); } } Weitere Möglichkeiten Das Beispiel könnte so umgeschrieben werden, dass von einer vordefinierten Zeit heruntergezählt wird und die Anzeige nach Erreichen von 0 entsprechend blinkt. In Kombination mit dem Buzzer wäre so sogar eine Eieruhr möglich.\nStatt jeweils nur die aktuelle Zeit mit LocalTime.now() anzuzeigen, könnte auch die aktuelle Uhrzeit in verschiedenen Zeitzonen hintereinander dargestellt werden.\nIn Kombination mit den vorhandenen Buttons lassen sich Eingaben für Zahlen realisieren, sodass beispielsweise eine Stoppuhr implementiert werden könnte.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button/","title":"Button","tags":["gpio"],"description":"","content":"Funktionsweise Bei einem Button handelt es sich schlicht um einen ganz einfachen Knopf, der entweder gedrückt wird oder eben nicht. Auf dem CrowPi stehen neben der Button Matrix auch vier unabhängige Knöpfe zur Verfügung, die mit den Richtungen Up (oben), Down (unten), Left (links), Right (rechts) bezeichnet sind.\nBei dieser Komponente wird der entsprechende GPIO-Pin direkt ausgelesen und ohne weitere Verarbeitung ausgewertet. Somit lässt sich diese Komponente sehr einfach verwenden und kann dennoch für viele unterschiedliche Zwecke eingesetzt werden.\nVoraussetzungen DIP Switches Für diese Komponente müssen die DIP Switches 1-5, 1-6, 1-7 sowie 1-8 aktiviert werden, da sich die Buttons sonst nicht oder nur eingeschränkt nutzen lassen. Die Stellung der DIP Switches sollte anschliessend so aussehen:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.ButtonComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung ButtonComponent(com.pi4j.context.Context pi4j pi4j, Button button) Initialisiert einen Button für den angegebenen Knopf vom CrowPi. ButtonComponent(com.pi4j.context.Context pi4j pi4j, int address, boolean inverted, long debounce) Initialisiert einen Button mit einer benutzerdefinierten Adresse und Entprellzeit. Der Parameter inverted kann gesetzt werden um einen Button mit Pull-Down Verfahren anzusprechen. Methoden Methode Bemerkung boolean isDown() Gibt true zurück falls der Knopf zurzeit gedrückt wird, ansonsten false. boolean isUp() Gibt true zurück falls der Knopf zurzeit nicht gedrückt wird, ansonsten true ButtonState getState() Gibt den aktuellen Zustand vom Knopf zurück. void onDown(SimpleEventHandler handler) Setzt den Event Handler welcher beim Drücken des Knopfs aufgerufen werden soll. null deaktiviert diesen Event Listener. void onUp(SimpleEventHandler handler) Setzt den Event Handler welcher beim Loslassen des Sensors aufgerufen werden soll. null deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.ButtonComponent Javadoc enthält alle möglichen Zustände, die vom Knopf zurückgegeben werden können.\ncom.pi4j.crowpi.components.definitions.Button Javadoc enthält die Pins der vier verschiedenen Knöpfe auf dem CrowPi und wird im Konstruktor verwendet werden, um den gewünschten Knopf anzugeben.\nBeispielapplikation Die Beispielapplikation ist sehr simpel gehalten und initialisiert alle 4 Knöpfe, um anschliessend auf jedem Knopf einen Event Handler für gedrückt (onDown) sowie losgelassen (onUp) zu registrieren. Anschliessend schläft die Applikation für 15 Sekunden, um ein Testen der verschiedenen Knöpfe zu ermöglichen.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/ButtonApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.ButtonComponent; import com.pi4j.crowpi.components.definitions.Button; /** * This example app initializes all four directional buttons and registers event handlers for every button. While this example itself does * not do much, it showcases how it could be used for controlling a player character in a game. Before the application exits it will cleanly * unregister all previously configured event handlers. */ public class ButtonApp implements Application { @Override public void execute(Context pi4j) { // Initialize all four button components final var upButton = new ButtonComponent(pi4j, Button.UP); final var downButton = new ButtonComponent(pi4j, Button.DOWN); final var leftButton = new ButtonComponent(pi4j, Button.LEFT); final var rightButton = new ButtonComponent(pi4j, Button.RIGHT); // Register event handlers to print a message for each button when pressed (onDown) and depressed (onUp) upButton.onDown(() -\u0026gt; System.out.println(\u0026#34;Alright, moving upwards!\u0026#34;)); downButton.onDown(() -\u0026gt; System.out.println(\u0026#34;Aye aye, moving downwards!\u0026#34;)); leftButton.onDown(() -\u0026gt; System.out.println(\u0026#34;Gotcha, moving to the left!\u0026#34;)); rightButton.onDown(() -\u0026gt; System.out.println(\u0026#34;Yep, moving to the right!\u0026#34;)); upButton.onUp(() -\u0026gt; System.out.println(\u0026#34;Stopped moving upwards.\u0026#34;)); downButton.onUp(() -\u0026gt; System.out.println(\u0026#34;Stopped moving downwards.\u0026#34;)); leftButton.onUp(() -\u0026gt; System.out.println(\u0026#34;Stopped moving to the left.\u0026#34;)); rightButton.onUp(() -\u0026gt; System.out.println(\u0026#34;Stopped moving to the right.\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press any of the 4 independent / directional buttons to see them in action!\u0026#34;); sleep(15000); // Unregister all event handlers to exit this application in a clean way // To keep the code more compact, we create a list of all four buttons and loop over it, unregistering both handlers for each for (final var button : new ButtonComponent[]{upButton, downButton, leftButton, rightButton}) { button.onDown(null); button.onUp(null); } } } Weitere Möglichkeiten Mit den vier Knöpfen lassen sich leicht diverse Spiele realisieren, da jeder Knopf in eine bestimmte Richtung zeigt, was sich als Steuerung für einen Spieler verwenden lässt. Ein einfaches Bespiel hierfür wäre das Spiel Snake. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/button-matrix/","title":"Button Matrix","tags":["gpio"],"description":"","content":"Funktionsweise Bei einer Button-Matrix handelt es sich einfach gesagt um ein Gitter von Knöpfen, also zum Beispiel 4 × 4 Knöpfe wie beim CrowPi. In der simpelsten Form könnte jeder Knopf einzeln mit einem GPIO Pin verbunden werden, jedoch stösst man auf diese Art und Weise schnell an die maximale Kapazität von GPIO Pins eines Raspberry Pi.\nBei einer anderen Methode, welche auch von der Button-Matrix auf dem CrowPi genutzt wird, wird die Kombination der beiden Achsen für das Auslesen der einzelnen Knöpfe verwendet. In der Komponente werden hierbei sogenannte Selector und Button Pins definiert, die dann zusammen das effiziente Anbinden einer Button-Matrix ermöglichen.\nDer Selector Pin legt hierbei jeweils fest, welche Spalte (vertikal) ausgelesen wird. Nachdem der Pin der gewünschten Spalte angesteuert wurde, können nun alle Zeilen (horizontal) dieser Spalte mithilfe der einzelnen Button Pins ausgelesen werden. Um den zweiten Knopf von links in der ersten Reihe einzulesen, muss zuerst der zweite Selector Pin aktiviert werden (= Spalte 2), um anschliessend den ersten Button Pin (= Zeile 1) auszulesen. Somit werden für ein 4 × 4 Gitter nur 8 statt 12 GPIO Pins benötigt.\nDies bedeutet jedoch auch, dass sich nun nicht mehr einfach so der Zustand eines Pins überwachen lässt, um Events für einen Knopf zu erhalten. Stattdessen muss nun eine Polling-Methode verwendet werden, sprich es müssen immer wieder Spalte für Spalte alle Knöpfe abgefragt werden. Diese Komplexität entfällt jedoch bei Nutzung der Komponente, da diese automatisch einen Poller im Hintergrund startet.\nDie Buttons auf dem CrowPi sind auf der Platine beschriftet und von links nach rechts, oben nach unten von 1 bis 16 durchnummeriert. Die Komponente nimmt bei allen Methoden jeweils diese Nummer entgegen, sprich 7 entspricht dem dritten Knopf von links in der zweiten Zeile.\nVoraussetzungen DIP Switches Für diese Komponente müssen alle DIP-Switches vom linken Block aktiviert werden, da sich die Button-Matrix sonst nicht oder nur teilweise nutzen lässt. Die Stellung der DIP Switches sollte anschliessend so aussehen:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.ButtonMatrixComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung ButtonMatrixComponent(com.pi4j.context.Context pi4j) Initialisiert eine Button-Matrix mit den Standardeinstellungen für den CrowPi. ButtonMatrixComponent(com.pi4j.context.Context pi4j, int[] selectorPins, int[] buttonPins, int[] stateMappings, long pollerPeriodMs) Initialisiert eine Button-Matrix mit frei definierbaren Selector / Button Pins, einem eigenen Mapping sowie einer benutzerdefinierten Polling-Dauer. Methoden Methode Bemerkung void startPoller(long pollerPeriodMs) Startet den Poller (siehe Funktionsweise) mit dem angegebenen Intervall. Diese Methode wird automatisch vom Konstruktor aufgerufen und muss normalerweise nicht verwendet werden. void stopPoller() Stoppt den Poller sofort und aktualisiert hiermit den Zustand der Buttons nicht mehr. int readBlocking() Wartet endlos darauf dass ein Knopf gedrückt und wieder losgelassen wird, um anschliessend dessen Nummer zurückzugeben. Im Fehlerfall wird der Wert -1 zurückgegeben. int readBlocking(long timeoutMs) Wartet bis zu timeoutMs Millisekunden darauf, dass ein Knopf gedrückt und wieder losgelassen wird. Verhält sich ansonsten gleich wie int readBlocking(). int[] getPressedButtons() Gibt die Nummern aller Knöpfe zurück, die zurzeit aktiv gedrückt werden. Falls keine Knöpfe gedrückt werden, so wird eine leere Liste zurückgegeben. boolean isDown(int number) Gibt true zurück falls der Knopf mit der angegebenen Nummer zurzeit gedrückt wird. boolean isUp(int number) Gibt true zurück falls der Knopf mit der angegebenen Nummer zurzeit nicht gedrückt wird. ButtonState getState(int number) Gibt den aktuellen Zustand vom Knopf mit der angegebenen Nummer zurück. void onDown(int number, SimpleEventHandler handler) Setzt den Event Handler, welcher beim Drücken des angegebenen Knopfs aufgerufen werden soll. null deaktiviert diesen Event Listener. void onUp(int number, SimpleEventHandler handler) Setzt den Event Handler, welcher beim Loslassen des angegebenen Knopfs aufgerufen werden soll. null deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.ButtonComponent Javadoc enthält alle möglichen Zustände, die von einem Knopf zurückgegeben werden können. Es wird hierbei absichtlich die Enumeration von der einfacheren ButtonComponent mitverwendet, um eine möglichst ähnliche Nutzung zu ermöglichen. Beispielapplikation Die folgende Beispielapplikation ist etwas komplexer und stellt ein vollständiges Spiel auf Basis der Button-Matrix dar. Es gleicht dem sogenannten Memory Game oder auch dem deutschen Spiel „Ich packe in meinen Koffer“. Zuerst werden mit der Hilfsmethode determinePlayers() alle Spielernamen gesammelt, welche am Spiel teilnehmen sollen. Die Methode sorgt hierbei dafür, dass mindestens zwei Spieler existieren, da dies eine Voraussetzung vom Spiel darstellt. Diese Spieler werden schliesslich in players gespeichert.\nAnschliessend wird eine leere Liste namens history erzeugt, die jeweils alle vorherigen Knöpfe bzw. deren Nummer beinhaltet. Nun ist das Spiel vollständig initialisiert und eine while-Schleife läuft bis nur noch ein aktiver Spieler existiert und alle anderen Spieler aufgrund eines falschen Zugs verloren haben.\nInnerhalb dieser Schleife wird mit einem Iterator jeweils der nächste Spieler ermittelt. Sobald der Iterator, welcher in der originalen Reihenfolge über alle Spieler iteriert, am Ende angekommen ist, wird dieser neu erstellt und startet damit wieder am Anfang. So kommt ein Spieler nach dem anderen zum Zug und dies lässt sich endlos wiederholen.\nNun erfolgen ein paar Ausgaben auf der Kommandozeile und danach eine for-Schleife, welche den Spieler auffordert, jeden vorherigen Zug der in history gespeichert wurde, zu wiederholen. Wird hierbei ein Fehler erkannt, so wird die Schleife vorzeitig verlassen und das Flag hasFailed auf true gesetzt. Falls dem Spieler keine Fehler passieren, endet die Schleife normal und der Wert von hasFailed bleibt auf false.\nIst hasFailed nach der Schleife nun gesetzt, so wird der Spieler über seinen Fehler informiert, aus der aktiven Spielerliste gelöscht und mit continue der nächste Spielzug forciert. War hingegen alles richtig, so kann der Spieler nun einen neuen Knopf wählen und der Zug des nächsten Spielers beginnt.\nWenn irgendwann nur noch ein aktiver Spieler verbleibt, so wird eine Gewinnmeldung und die totale Punktzahl, welche der Anzahl an wiederholten Elementen entspricht, ausgegeben. Bevor die Applikation endet, wird noch der Poller gestoppt um die Button Matrix nicht länger abzufragen und somit Ressourcen freizugeben.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/ButtonMatrixApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.ButtonMatrixComponent; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; /** * This example is actually also known as \u0026#34;memory game\u0026#34; or \u0026#34;Ich packe meinen Koffer mit ...\u0026#34; in German. During startup, it will first ask * for at least two players which will play against each other. Once all players have been entered, the actual game starts. During each turn * the player has to repeat all the previously pressed buttons in the same order and then pick a new button. The active player loses if an * incorrect button is pressed while having to repeat the previous ones. Otherwise, the game will move to the next player. The last player * remaining automatically wins the game. */ public class ButtonMatrixApp implements Application { @Override public void execute(Context pi4j) { // Initialize button matrix component final var buttonMatrix = new ButtonMatrixComponent(pi4j); // Initialize game state final List\u0026lt;String\u0026gt; players = determinePlayers(); final List\u0026lt;Integer\u0026gt; history = new ArrayList\u0026lt;\u0026gt;(); // Repeat the game loop until there is only a single active player left // This means the game will go on until everyone but one has lost var playerIterator = players.iterator(); while (players.size() \u0026gt;= 2) { // Determine active player by fetching the next active player from the list // An iterator basically loops over all entries and returns one after another each time .next() is called // When we reach the end of the iterator (hasNext() returns false), we create a new iterator to start from the beginning if (!playerIterator.hasNext()) { playerIterator = players.iterator(); } final var activePlayer = playerIterator.next(); // Print a message which informs about the currently active player whose turn it is System.out.println(); System.out.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt; NEXT TURN: Good luck, \u0026#34; + activePlayer); // Print a message about the total number of moves which have to be repeated if (history.size() \u0026gt; 0) { System.out.println(\u0026#34;Please repeat all previous \u0026#34; + history.size() + \u0026#34; button presses in order...\u0026#34;); } // Make the player repeat the whole history and abort if incorrect boolean hasFailed = false; for (int i = 0; i \u0026lt; history.size(); i++) { // Wait for the player to press a button final int number = buttonMatrix.readBlocking(); // Compare the button with the history at the currently checked position \u0026#34;i\u0026#34; // If incorrect, break out of this loop with the failed flag set to true if (number != history.get(i)) { hasFailed = true; break; } // Inform the user about the remaining moves if there are any final int movesLeft = history.size() - i - 1; if (movesLeft \u0026gt; 0) { System.out.println(\u0026#34;Correct! \u0026#34; + (history.size() - i - 1) + \u0026#34; more numbers to go...\u0026#34;); } else { System.out.println(\u0026#34;Well done, you\u0026#39;ve repeated all buttons correctly!\u0026#34;); } } // If the player has failed, print a message, remove the player and continue with the next turn if (hasFailed) { System.out.println(\u0026#34;Incorrect! You\u0026#39;ve lost and are out, \u0026#34; + activePlayer + \u0026#34;!\u0026#34;); playerIterator.remove(); continue; } // Let the player choose a new button which shall be added to the history System.out.println(\u0026#34;Press any button of your choice to add it to the list...\u0026#34;); final int number = buttonMatrix.readBlocking(); // Add the chosen number to the history and print it on the CLI history.add(number); System.out.println(\u0026#34;Turn completed, button \u0026#34; + number + \u0026#34; has been added.\u0026#34;); } // Print the winner, which will be the last and single element in the list System.out.println(\u0026#34;Congratulations, \u0026#34; + players.get(0) + \u0026#34;, you have won!\u0026#34;); System.out.println(\u0026#34;Your score: \u0026#34; + history.size() + \u0026#34; points\u0026#34;); // Stop the button matrix poller now that the application has ended buttonMatrix.stopPoller(); } private List\u0026lt;String\u0026gt; determinePlayers() { // Initialize empty list of players final var players = new ArrayList\u0026lt;String\u0026gt;(); // Initialize buffered reader for reading from command line final var reader = new BufferedReader(new InputStreamReader(System.in)); // Gather player names from command line while (true) { // Print prompt to ask for the player names if (players.size() \u0026gt;= 2) { System.out.print(\u0026#34;Please enter another player name or nothing to start the game: \u0026#34;); } else { System.out.print(\u0026#34;At least 2 players are needed. Please enter a player name: \u0026#34;); } // Read the next player name from command line final String player; try { player = reader.readLine(); } catch (IOException e) { continue; } // Determine if we are ready to start the game or need more players if (players.size() \u0026gt;= 2 \u0026amp;\u0026amp; player.isEmpty()) { break; } else if (!player.isEmpty()) { players.add(player); } } return players; } } Weitere Möglichkeiten Das bestehende Spiel um LCD Display und/oder Buzzer erweitern, um gewisse Ausgaben direkt auf dem CrowPi zu erzeugen und je nach Knopfdruck einen anderen Ton / eine andere Frequenz abzuspielen. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/buzzer/","title":"Buzzer","tags":["pwm"],"description":"","content":"Funktionsweise Der Buzzer funktioniert wie ein Lautsprecher, jedoch mit dem Unterschied, dass dieser technisch gesehen nur einen einzigen Ton abspielen kann. Dank der Verwendung von PWM ist es jedoch möglich diesen auch so anzusteuern, dass damit entsprechende Melodien mit verschiedenen Tönen abgespielt werden können.\nDie Klasse BuzzerComponent verwendet eine solche PWM-Implementation und bietet eine einfache Schnittstelle, mit welcher beliebige Töne abgespielt werden können. Um eine zuverlässige Wiedergabe der gewünschten Frequenzen zu ermöglichen, verwendet diese Komponente Hardware PWM. Mehr Informationen dazu finden sich auf der verlinkten Seite.\nUm das mühsame Abtippen der einzelnen Frequenzen zu erleichtern, wird zudem eine Hilfsklasse Note bereitgestellt. Dieser Aufzählungstyp enthält alle bekannten Musiknoten von B0 zu DS8 und bildet diese auf die entsprechenden Tonfrequenzen ab, sodass diese direkt an die playTone() Methode übergeben werden können.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.BuzzerComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung BuzzerComponent(com.pi4j.context.Context pi4j) Initialisiert einen Buzzer mit dem Standard-Pin für den CrowPi. BuzzerComponent(com.pi4j.context.Context pi4j, int address) Initialisiert einen Buzzer mit einem benutzerdefinierten Pin. Methoden Methode Bemerkung void playTone(int frequency) Spielt dauerhaft einen Ton mit der gewünschten Frequenz. void playTone(int frequency, int duration) Spielt einen Ton mit der gewünschten Frequenz für die angegebene Zeit in Millisekunden. void playSilence() Schaltet den Buzzer dauerhaft aus. void playSilence(int duration) Schaltet den Buzzer dauerhaft aus und wartet für die angegebene Zeit in Millisekunden. Beispielapplikation Die nachfolgende Beispielapplikation steuert den Buzzer via PWM an, um eine bekannte Melodie abzuspielen. Hierfür wird ein Enum namens Note verwendet, welches die entsprechenden Musiknoten auf eine Frequenz [Hz] für PWM abbildet, dies klingt dann wie der gesuchte Ton. Die Applikation spielt nacheinander alle Noten ab, indem die Funktionen playTone sowie playSilence der Buzzer-Komponente verwendet werden.\nDie Noten, die gespielt werden sollen, sind alle in der statischen Variable NOTES zu finden, welche durch die zusätzliche statische Variable mit dem Namen TEMPO um die Angabe der Notenlänge ergänzt wird. Die Applikation iteriert schliesslich mit einer for-Schleife über alle Noten und spielt diese mit der jeweiligen Länge ab.\nDie effektive Länge in Millisekunden wird mit der Formel 1 / \u0026lt;tempo\u0026gt; berechnet, sodass ein Tempo-Wert von 4 einer Viertelnote mit 0.25 Sekunden Länge entspricht. Damit sich die Noten besser voneinander unterscheiden lassen, wird zudem jeweils noch eine kleine Pause mit dem Faktor 1.3 eingefügt.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/BuzzerApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.BuzzerComponent; import com.pi4j.crowpi.helpers.Note; /** * Plays the Super Mario Overworld theme song over the builtin CrowPi buzzer. * Notes taken from https://www.hackster.io/jrance/super-mario-theme-song-w-piezo-buzzer-and-arduino-1cc2e4 */ public class BuzzerApp implements Application { /** * Array of notes which should be played by this example */ private static final Note[] NOTES = new Note[]{ Note.E7, Note.E7, Note.PAUSE, Note.E7, Note.PAUSE, Note.C7, Note.E7, Note.PAUSE, Note.G7, Note.PAUSE, Note.PAUSE, Note.PAUSE, Note.G6, Note.PAUSE, Note.PAUSE, Note.PAUSE, Note.C7, Note.PAUSE, Note.PAUSE, Note.G6, Note.PAUSE, Note.PAUSE, Note.E6, Note.PAUSE, Note.PAUSE, Note.A6, Note.PAUSE, Note.B6, Note.PAUSE, Note.AS6, Note.A6, Note.PAUSE, Note.G6, Note.E7, Note.G7, Note.A7, Note.PAUSE, Note.F7, Note.G7, Note.PAUSE, Note.E7, Note.PAUSE, Note.C7, Note.D7, Note.B6, Note.PAUSE, Note.PAUSE, Note.C7, Note.PAUSE, Note.PAUSE, Note.G6, Note.PAUSE, Note.PAUSE, Note.E6, Note.PAUSE, Note.PAUSE, Note.A6, Note.PAUSE, Note.B6, Note.PAUSE, Note.AS6, Note.A6, Note.PAUSE, Note.G6, Note.E7, Note.G7, Note.A7, Note.PAUSE, Note.F7, Note.G7, Note.PAUSE, Note.E7, Note.PAUSE, Note.C7, Note.D7, Note.B6, Note.PAUSE, Note.PAUSE, }; /** * Array of note types, e.g. 4 represents a quarter-note with 0.25s duration. * Must have the same length as the NOTES array. */ private static final int[] TEMPO = new int[]{ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, }; @Override public void execute(Context pi4j) { // Initialize buzzer component with default pin final var buzzer = new BuzzerComponent(pi4j); // Loop through all notes and play them one-by-one for (int i = 0; i \u0026lt; NOTES.length; i++) { // Calculate duration of note by dividing one second with tempo // Tempo represents the actual note type, e.g. tempo=4 -\u0026gt; quarter note -\u0026gt; 0.25s final var duration = 1000 / TEMPO[i]; // Print note to standard output, play over buzzer System.out.print(NOTES[i] + \u0026#34;(\u0026#34; + duration + \u0026#34;) \u0026#34;); buzzer.playTone(NOTES[i].getFrequency(), duration); // Wait shortly between notes to make them more distinguishable buzzer.playSilence((int) (duration * 1.3)); } } } Weitere Möglichkeiten Das Beispiel kann einfach auf eine eigene Melodie angepasst werden, wofür jeweils lediglich die beiden Arrays NOTES und TEMPO angepasst werden müssen. Hier ist darauf zu achten, dass diese Arrays jeweils die gleiche Länge besitzen müssen, da jede Note auch eine dazugehörige Länge benötigt.\nStatt dem Abspielen einer Melodie könnte auch eine Sirene mit einer for-Schleife implementiert werden. Hierfür muss die Frequenz manuell als Zahl angegeben werden statt der Verwendung der Note Klasse, welche sich beispielsweise mit dem Einsatz von for-Schleifen hoch- und runterzählen lässt.\nBelegt man jeden Kopf der Button-Matrix mit einem eigenen Ton / Frequenz könnte man daraus seine eigene Melodie komponieren.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/","title":"CrowPi goes Java","tags":[],"description":"","content":" CrowPi goes Java Herzlich willkommen auf der Startseite des Tutorials \u0026ldquo;CrowPi goes Java\u0026rdquo;.\nDas Tutorial führt in die Nutzung des CrowPi als einsteigerfreundliche Lernplattform für die Programmierung von Hardwarekomponenten mit Java ein.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/tags/gpio/","title":"gpio","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/tags/i2c/","title":"i2c","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/i2c/","title":"I²C","tags":["i2c"],"description":"","content":"Das Wichtigste in Kürze I²C (gesprochen Englisch als I-Squared-C) ist ein ursprünglich von Philips erfundener Bus. Er ist als klassischer Master-Slave-Bus konzipiert. Hierbei wird eine Datenübertragung immer durch einen Master initiiert. Auch ein Aufbau in einem Multi-Master System ist möglich. Angeschlossen wird I²C über zwei Signalleitungen (Datenleitung und Taktleitung). Die Übertragungsrate des Buses kann je nach Taktrate zwischen 0.1 Mbit/s bis zu 3.4 Mbit/s liegen. Sofern nur eine unidirektionale Verbindung nötig ist, wäre sogar 5.0 Mbit/s möglich. Zu beachten ist dabei: Je höher die Taktrate, desto störungsanfälliger wird das Gesamtsystem. Die niedrige Betriebsspannung von nur 3.3V trägt ebenfalls nicht zur Störresistenz bei.\nVerwendungen I²C wird vor allem zur Kommunikation zwischen Mikrocontrollern eingesetzt. Der Vorteil, dass dabei über nur 2 Leitungen eine ganze Reihe von Mikrocontrollern gesteuert werden kann, ist natürlich sehr interessant für das Platinenlayout. Die Vorteile von I²C liegen vor allem in der Einfachheit. Es gibt sehr wohl neuere Bussysteme mit besseren Übertragungsraten. Kaum ein Bussystem ist jedoch so einfach zu benutzen wie I²C. Sogar ein \u0026ldquo;Hot-Plugging\u0026rdquo; also ein ein- und ausstecken der Geräte während dem Betrieb ist mit I²C möglich.\nAdressierung I²C nutzt einen Adressraum von 7 Bit. Das erlaubt bis zu 112 Knoten auf einem Bus. Die restlichen 16 Adressen sind für spezielle Anwendungen reserviert. Normalerweise wird die Adresse eines Geräts direkt vom Hersteller definiert. Sie kann also in den entsprechenden Datenblättern gefunden werden. Zusätzlich gibt es aufgrund der Adressknappheit eine Variante mit 10 Bit Adressraum. So sind bis zu 1136 Knoten möglich und das Protokoll ist kompatibel mit dem kleineren 7 Bit Adressraum.\nÜbertragungsraten Modus Max. Übertragungsrate Richtung Standard Mode 0.1 Mbit/s bidirektional Fast Mode 0.4 Mbit/s bidirektional Fast Mode Plus 1.0 Mbit/s bidirektional High Speed Mode 3.4 Mbit/s bidirektional Ultra Fast-mode 5.0 Mbit/s unidirektional Weitere Informationen Wikipedia I²C I²C Bus "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ir-receiver/","title":"Infrarot Empfänger","tags":["gpio"],"description":"","content":"Funktionsweise Mithilfe von Infrarot können über einige Meter Distanz digitale Informationen übertragen werden, was beispielsweise oft für die Fernbedienung eines Fernsehers genutzt wird. Die Übertragungsart gleicht hierbei dem Prinzip des Morsens, da die Infrarot-LED im Sendegerät eine Abfolge von Bits durch unterschiedlich lange Pausen zu dem Empfängergerät überträgt. Da jedoch auch viele andere Dinge in der Natur, wie beispielsweise unsere Sonne, ein Infrarot-Licht emittieren, wird für die elektronische Verwendung nur eine Frequenz von 38kHz verwendet.\nUm zu vermeiden, dass eine Fernbedienung über eine oder gar mehrere Sekunden komplett still gehalten werden muss, werden die einzelnen Bits in sehr kurzen zeitlichen Abständen übertragen. Dies klingt im ersten Moment natürlich praktisch, bedeutet jedoch auch, dass das empfangende Gerät in der Lage sein muss sehr präzise zeitliche Messungen durchführen zu können. Genau dies war jedoch beim CrowPi mit der Verwendung von Java in Kombination mit Pi4J nicht möglich, da eine Genauigkeit von rund 60 Mikrosekunden (0.00006 Sekunden) benötigt wird, was sich mit dem Design der Java Virtual Machine nicht umsetzen lässt.\nUm diese Komponente jedoch trotzdem zur Verfügung zu stellen, nutzt diese Implementation eine vorinstallierte Applikation namens mode2 welche in C geschrieben wurde. Diese gibt die entsprechend erkannten Signale über die Konsole aus, welche dann automatisch in Java ausgewertet, geprüft und weitergegeben werden. Ein grosser Teil der Logik ist somit weiterhin innerhalb dieser Komponenten-Klasse aufzufinden, das Erkennen der Signale findet jedoch nicht mit Pi4J statt. Sollten sich hier in Zukunft neue Möglichkeiten ergeben, so würde sich die Komponente regulär via GPIO auslesen lassen.\nEine saubere Alternative, die sich weiterhin mit Pi4J umsetzen lässt, wäre einen dedizierten Mikrocontroller für das Empfangen der Infrarot-Signale zu verwenden, welcher dann über einen anderen Bus wie beispielsweise I²C oder SPI die Signale an den Raspberry Pi sendet. Auf dem CrowPi ist dies jedoch nicht vorhanden, sodass diese Möglichkeit nicht besteht.\nFür die Verwendung dieser Komponente muss die beigelegte Infrarot-Diode auf dem CrowPi in die 3 Pin-Header eingesteckt werden, da sich diese nicht direkt auf dem CrowPi befindet. Auf dem nachfolgenden Foto ist angegeben, wo die Infrarot-Photodiode einzustecken ist:\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.IrReceiverComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung IrReceiverComponent() Initialisiert einen Infrarot-Empfänger mit Standardeinstellungen für den CrowPi. IrReceiverComponent(String mode2Binary, String devicePath) Initialisiert einen Infrarot-Empfänger mit benutzerdefiniertem Pfad zur mode2 Applikation sowie einem Gerätepfad. Methoden Methode Bemerkung void onKeyPressed(EventHandler\u0026lt;Key\u0026gt; handler) Setzt den Event Handler, welcher gedrückte Tasten auf der Infrarot-Fernbedienung als ersten Parameter erhält. Durch die Angabe von null kann das Empfangen von Infrarot-Signalen deaktiviert werden. Enumerationen com.pi4j.crowpi.components.IrReceiverComponent Javadoc enthält alle unterstützten Tasten, welche sich auf der beigelegten Infrarot-Fernbedienung des CrowPi befinden. Diese Enumeration kann genutzt werden, um innerhalb eines Events die erhaltene Taste zu vergleichen und unterschiedliche Aktionen durchzuführen. Beispielapplikation Die Beispielapplikation initialisiert zuerst den Infrarot-Empfänger, wobei hier nicht einmal der übliche Pi4J-Kontext übergeben werden muss, da wie bereits weiter oben beschrieben, von dieser Komponente die Pi4J-Library nicht genutzt wird. Nach erfolgter Initialisierung wird ein Event Handler registriert, der jeden Tastendruck auf der Konsole ausgibt sowie beim Drücken der \u0026ldquo;CH\u0026rdquo; Taste eine zusätzliche Ausgabe vornimmt. Anschliessend wird 30 Sekunden gewartet, bevor der Event Handler wieder deaktiviert wird und die Applikation sich beendet.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/IrReceiverApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.IrReceiverComponent; /** * This example demonstrates the infrared receiver component on the CrowPi. Please note that the receiver LED must first be plugged into the * three small pinholes labelled as \u0026#34;IR\u0026#34; for this example to work. As Java does not allow for precise enough timings itself, this component * does not use Pi4J to retrieve the pulses of the GPIO pin for the IR sensor and instead relies on mode2, an executable provided as part of * LIRC for reading from an IR input. * \u0026lt;p\u0026gt; * A clean alternative would be using a separate microcontroller which handles the super precise timing-based communication itself and * interacts with the Raspberry Pi using I²C, SPI or any other bus. This would offload the work and guarantee even more accurate results. As * the CrowPi does not have such a dedicated microcontroller though, using `mode2` was the best available approach. */ public class IrReceiverApp implements Application { @Override public void execute(Context pi4j) { // Initialize the IR receiver component // We do not use Pi4J here at all, so there is no need to pass the context... final var ir = new IrReceiverComponent(); // Register an event listener for key presses System.out.println(\u0026#34;Welcome to the IR demo! An event listener for key presses will now be registered...\u0026#34;); ir.onKeyPressed(key -\u0026gt; { // Print the key which just has been pressed System.out.println(\u0026#34;Key on IR remote has been pressed: \u0026#34; + key); // It is also possible to check if a specific key was pressed if (key == IrReceiverComponent.Key.CH) { System.out.println(\u0026#34;You pressed the super special CH key! (it is actually not special, sorry to disappoint)\u0026#34;); } }); // Give the user some time to press buttons System.out.println(\u0026#34;Done! You now have 30 seconds to try out pressing various keys on the IR remote...\u0026#34;); sleep(30000); // Cleanup the event listener ir.onKeyPressed(null); } } Weitere Möglichkeiten Mit der beigelegten Fernbedienung lassen sich einwandfrei numerische Eingaben tätigen, z.B. um einen einfachen Taschenrechner mit Addition und Subtraktion zu bauen, wofür sich die Zahlentasten sowie Plus und Minus nutzen lassen würden. Dieser liesse sich auch mit dem LCD-Display kombinieren.\nDie Steuerungstasten für Previous, Next sowie Play/Pause könnten genutzt werden, um den Buzzer zu steuern und verschiedene Melodien damit abzuspielen.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/lcd-display/","title":"LCD Display","tags":["gpio","i2c"],"description":"","content":"Funktionsweise Beim LCD Display handelt es sich um eine der komplexesten Komponenten des CrowPi. Diese betrifft sowohl die Ansteuerung in der Software, als auch die Funktionalität des Displays an sich. Das LCD-Display verfügt auf 2 Zeilen jeweils über 16 kleine Pixelfelder. Diese bestehen aus je 5x8 Pixeln. Jedes dieser Pixel wird von den Mikrocontrollern des Displays einzeln angesteuert um so Buchstaben, Zahlen und Sonderzeichen zu zeigen. Auf diese Weise können also bis zu 32 Zeichen gleichzeitig angezeigt werden. Damit nun der Benutzer nicht jedes Pixel einzeln ansteuern muss, sind schon die wichtigsten Zeichen vorprogrammiert. Es können a-Z, 0–9 und einige Sonderzeichen einfach genutzt werden. Um dem Benutzer noch mehr Möglichkeiten zu offerieren, können zudem noch 8 benutzerdefinierte Zeichen erfasst werden. Durch diese Vielfältigkeit und doch schon eine beachtliche Menge an Platz für die Anzeige von Text und Zahlen bieten sich unzählige Anwendungsmöglichkeiten für ein solches LCD-Display.\nDie Ansteuerung des Displays erfolgt über einfache digitale Signale. Da jedoch 8 Stück benutzt werden und der Raspberry Pi nur wenige zur Verfügung hat, gibt es eine kleine Zwischenschaltung. Es wird ein Baustein verwendet, der mittels I²C einige zusätzliche digitale Ein- und Ausgänge zur Verfügung stellt. Auf dem Bild ist diese Verschaltung nochmals skizziert: Die Helligkeit des Displays wird bei dem Aufbau im CrowPi mit einem Potentiometer eingestellt. Mit dem Schraubenzieher kann dieses so eingestellt werden bis das Display einen optimalen Kontrast hat und alles gut lesbar ist. Das Potentiometer befindet sich direkt links neben dem Display. Es ist relativ klein und kann gut übersehen werden. Nachfolgend wird es daher abgebildet. Die verbaute Hardware beim CrowPi ist ein MCP23008 I/O Expander mit einem 1602A-1 LCD Display.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.LcdDisplayComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung LcdDisplayComponent(com.pi4j.context.Context pi4j) Initialisiert ein LCD-Display mit der Standard Bus- und Geräteadresse. LcdDisplayComponent(com.pi4j.context.Context pi4j, int address) Initialisiert ein LCD-Display mit einer benutzerdefinierten Bus- und Geräteadresse. Methoden Methode Bemerkung void initialize() initialisiert das Display und bereitet alles für die Benutzung vor. void writeCharacter(char c) Schreibt einen einzelnen Character auf die aktuelle Cursorposition. void writeCharacter(char c, int digit, int line) Schreibt einen einzelnen Character auf die übergebene Displayposition. void writeLine(String text, int line) Schreibt den maximal 16 Zeichen langen Text auf die in gewählte Zeile des Displays. void writeText(String text) Schreibt einen 32 Zeichen langen Test auf beide Zeilen des Displays. Der Zeilenumbruch funktioniert automatisch oder kann mit \\n eingefügt werden. void moveCursorHome() Bewegt den Cursor an die Position erste Zeile erstes Zeichen. void moveCursorRight() Bewegt den Cursor eine Stelle nach rechts. void moveCursorLeft() Bewegt den Cursor eine Stelle nach links. void setCursorToPosition(int digit, int line) Bewegt den Cursor auf angegebene Position. void setCursorToLine(int line) Schiebt den aktuellen Zeiger auf die gewünschte Zeile des Displays. void setCursorVisibility(boolean show) Hiermit kann der Cursor angezeigt (true) oder versteckt (false) werden. void setCursorBlinking(boolean blink) Das Feld, auf dem der Cursor sich aktuell befindet, blinkt (true) oder nicht (false). void moveDisplayRight() Bewegt alles auf dem Display um eine Stelle nach rechts. void moveDisplayLeft() Bewegt alles auf dem Display um eine Stelle nach links. void createCharacter(int location, byte[] character) Erstellt einen benutzerdefinierten Charakter auf der gewünschten Speicherstelle. Das Array muss genau der Länge acht entsprechen. void setDisplayBacklight(boolean state) Schaltet die Hintergrundbeleuchtung des Displays ein oder aus. void clearDisplay() Löscht alle auf dem Display gezeigten Zeichen. void clearLine(int line) Löscht alle Zeichen auf einer gewählten Zeile. Enumerationen com.pi4j.crowpi.components.LcdDisplayComponent Javadoc enthält alle unterstützten Symbole, die von dieser Komponenten-Klasse dargestellt werden können. Es handelt sich hierbei um eine Sammlung von ASCII-Codes sowie diversen Symbolen. Zusätzlich können mit \\1 bis \\7 die eigenen Zeichen aufgerufen und eingefügt werden. Die Werte sind jeweils als byte hinterlegt, was der internen Darstellung des LCD-Displays entspricht. Beispielapplikation In der Beispielapplikation werden verschiedenste Varianten der Text- und Zeichenausgabe mit dem LCD-Display demonstriert. Als erster Schritt wird auf zwei Zeilen einzeln der Klassiker Hello World! ausgegeben. Anschliessend folgt eine sehr spannende Funktion. Diese erlaubt es eigene Zeichen zu definieren. Bis zu 7 verschiedene Zeichen sind gleichzeitig speicherbar. Mit etwas Fantasie lassen sich so die verschiedensten Symbole erstellen. Nun folgen nochmals einige Textausgaben. Während diesen Ausgaben wird kurz der Cursor angezeigt. Dieser stellt jeweils die aktuelle Schreibposition des Displays dar. Er kann auch sehr einfach verschoben werden. Dies wird kurz demonstriert. Zum Abschluss folgen nochmals einige Textausgaben auch in Kombination mit manuellen Zeilenumbrüchen. Dazu wird ein \\n in den String eingefügt. Dies erzeugt dann sofort einen Zeilenumbruch. Pfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/LcdDisplayApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.LcdDisplayComponent; /** * Example Application of using the Crow Pi LCD Display */ public class LcdDisplayApp implements Application { @Override public void execute(Context pi4j) { LcdDisplayComponent lcd = new LcdDisplayComponent(pi4j); System.out.println(\u0026#34;Here we go.. let\u0026#39;s have some fun with that LCD Display!\u0026#34;); // First we need to setup the LCD Display. That for just call initialize lcd.initialize(); // Write text to the lines separate lcd.writeLine(\u0026#34;Hello\u0026#34;, 1); lcd.writeLine(\u0026#34; World!\u0026#34;, 2); // Wait a little to have some time to read it sleep(3000); // Clear the display to start next parts lcd.clearDisplay(); // Let\u0026#39;s try to draw a house. To keep this method short and clean we create the characters in a separate // method below. createCharacters(lcd); // Now all characters are ready. Just draw them on the right place by moving the cursor and writing the // created characters to specific positions lcd.writeCharacter(\u0026#39;\\1\u0026#39;, 1, 1); lcd.writeCharacter(\u0026#39;\\2\u0026#39;, 2, 1); lcd.writeCharacter(\u0026#39;\\3\u0026#39;, 1, 2); lcd.writeCharacter(\u0026#39;\\4\u0026#39;, 2, 2); // Delay a few seconds to let you enjoy our little house sleep(3000); // Uhm but the view from our house would be better from the other side. lets move it over there for (int i = 0; i \u0026lt; 10; i++) { lcd.moveDisplayRight(); sleep(100); } // Enjoy the new view from our house sleep(5000); // To clean up or start with something new just use the clearDisplay method lcd.clearDisplay(); // To write some text there are different methods. The simplest one is this one which automatically inserts // linebreaks if needed. lcd.writeText(\u0026#34;Boohoo that\u0026#39;s so simple to use!\u0026#34;); // Delay again sleep(3000); // Of course it is also possible to write a single line lcd.writeLine(\u0026#34;hard to usE!\u0026#34;, 2); sleep(3000); // The display always works with a current position. That\u0026#39;s called the cursor. You can simply modify the // cursor with a few method calls lcd.setCursorVisibility(true); lcd.setCursorBlinking(true); // Now you can see the cursor is right behind the last character we wrote before. sleep(5000); // The last text had a mistake so let\u0026#39;s move there and fix it. lcd.moveCursorLeft(); lcd.moveCursorLeft(); lcd.moveCursorLeft(); sleep(1000); // Oops moved too far, lets move one to the right lcd.moveCursorRight(); // And fix it lcd.writeCharacter(\u0026#39;e\u0026#39;); // Now it looks fine sleep(3000); // Cursor annoying? Simply turn it off and clear the display again lcd.setCursorBlinking(false); lcd.setCursorVisibility(false); lcd.clearDisplay(); // Some more text writings lcd.writeText(\u0026#34;Want more fun?\u0026#34;); sleep(3000); // Its also possible to just clear a single line lcd.clearLine(2); // Write on the previously cleared line lcd.writeLine(\u0026#34;No, thanks.\u0026#34;, 2); sleep(3000); // A \\n makes a manual line break lcd.writeText(\u0026#34;Okay ...\\nBye Bye! :-(\u0026#34;); sleep(5000); // Turn off the backlight makes the display appear turned off lcd.setDisplayBacklight(false); } public void createCharacters(LcdDisplayComponent lcd) { // Create upper left part of the house lcd.createCharacter(1, new byte[]{ 0b00000, 0b00000, 0b00000, 0b00001, 0b00011, 0b00111, 0b01111, 0b11111 }); // Create upper right part of the house lcd.createCharacter(2, new byte[]{ 0b00000, 0b00000, 0b00010, 0b10010, 0b11010, 0b11110, 0b11110, 0b11111 }); // Create lower left part of the house lcd.createCharacter(3, new byte[]{ 0b11111, 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b10001 }); // Create lower right part of the house lcd.createCharacter(4, new byte[]{ 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b11111, 0b11111 }); } } Weitere Möglichkeiten Das Display mit anderen Komponenten kombinieren. Dabei bieten sich unzählige Möglichkeiten. Es könnten beispielsweise die aktuelle Temperatur oder Helligkeit angezeigt werden.\nEine Karaoke Maschine. Mittels des Buzzers einen Song abspielen und auf dem Display jeweils den aktuellen Text anzeigen.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/led-matrix/","title":"LED Matrix","tags":["spi"],"description":"","content":"Funktionsweise Bei der LED Matrix handelt es sich um eine Anzeige, die aus einem Gitter von LEDs besteht. Im konkreten Fall vom CrowPi steht eine quadratische 8×8 LED Matrix zur Verfügung, sodass insgesamt 64 individuelle LEDs gesteuert werden können. Damit können neben der statischen Anzeige von Buchstaben, Zahlen und Symbolen auch einfache Animationen realisiert werden.\nZur Ansteuerung der einzelnen LEDs wären individuell steuerbare Leitungen unpraktisch, weshalb der elektronische Baustein MAX7219 verwendet wird. Dieser ermöglicht die Steuerung der gesamten LED Matrix über die SPI-Schnittstelle, sodass lediglich drei Pins benötigt werden.\nDa das Übertragen jeder einzelnen Änderung an die Komponente sehr ineffizient ist, wird üblicherweise ein Buffer in der Software implementiert. Alle gewünschten Anpassungen verändern somit nur den Buffer, der anschliessend mit nur einem einzigen Befehl übertragen werden kann. Dieses Prinzip wird auch von der Komponenten-Klasse LedMatrixComponent verwendet.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.LedMatrixComponent Javadoc beschrieben. Es handelt sich hierbei um eine sehr mächtige und komplexe Klasse, da eine Vielzahl von Funktionalitäten angeboten wird. Ein Blick auf das Beispiel zeigt jedoch, dass sich diese weiterhin sehr einfach anwenden lässt.\nEs ist hierbei wichtig zu beachten, dass die beiden Methoden setPixel und getPixel, welche auch mit dem Wort \u0026ldquo;Buffer:\u0026rdquo; am Anfang gekennzeichnet wurden, nicht direkt eine Auswirkung auf die Anzeige haben, sondern erst nach Aufruf von void refresh() aktiv werden. Somit lassen sich viele einzelne Pixel setzen, welche dann mit einem einzelnen Aufruf an die Anzeige übermittelt werden. Alle anderen Befehle werden jeweils sofort ausgeführt, da diese immer die ganze Anzeige betreffen.\nKonstruktoren Konstruktor Bemerkung LedMatrixComponent(com.pi4j.context.Context pi4j) Initialisiert eine LED Matrix mit der Standard SPI Adresse und Bandbreite für den CrowPi. LedMatrixComponent(com.pi4j.context.Context pi4j, int channel, int baud) Initialisiert eine LED Matrix mit einer benutzerdefinierten SPI Adresse und Bandbreite. Methoden Methode Bemerkung void setEnabled(boolean enabled) Schaltet die Anzeige ein oder aus gemäss Boolean-Wert. void setTestMode(boolean enabled) Schaltet den Testmodus der Anzeige ein oder aus. Ist dieser eingeschaltet, leuchten alle LEDs bedingungslos auf und alle anderen Operationen werden nicht ausgeführt. void setBrightness(int brightness) Setzt die gewünschte Helligkeit der ganzen Anzeige zwischen 0 (am dunkelsten) und 15 (am hellsten). void setPixel(int x, int y, boolean enabled) Buffer: Schaltet einen einzelnen Pixel an der gewünschten Stelle ein (true) oder aus (false). boolean getPixel(int x, int y) Buffer: Gibt den aktuellen Zustand eines einzelnen Pixels an der gewünschten Stelle an. void clear() Löscht den internen Buffer ohne die Anzeige zu aktualisieren. void refresh() Aktualisiert die Anzeige mit dem aktuellen Inhalt des Buffers. void scroll(Direction direction) Scrollt die Anzeige und lässt die hierbei entstehende Lücke leer. void rotate(Direction direction) Scrollt die Anzeige und verschiebt die \u0026ldquo;herausgefallene\u0026rdquo; Zeile / Spalte ans andere Ende. void print(String string) Gibt den String auf der Anzeige mit einem Scroll-Effekt von rechts nach links aus. Die Anzeige wird hierbei vor und nach der Ausgabe automatisch gelöscht. Mit dem Muster {SYMBOL-NAME} innerhalb der Zeichenkette können Symbole in den Text eingebunden werden. void print(String string, Direction scrollDirection) Gleiche Funktion wie print(String), jedoch mit einer benutzerdefinierten Richtung. void print(String string, Direction scrollDirection, long scrollDelay) Gleiche Funktion wie void print(String, Direction), jedoch mit benutzerdefinierten zeitlichen Abständen in Millisekunden zwischen dem Scrollen. void print(char c) Gibt das gewünschte Zeichen sofort auf der Anzeige aus. void print(Symbol s) Gibt das gewünschte Symbol sofort auf der Anzeige aus. void transition(Symbol symbol) Schiebt das Symbol in die Anzeige von rechts nach links rein. void transition(Symbol symbol, Direction scrollDirection) Gleiche Funktion wie transition(Symbol), jedoch mit einer benutzerdefinierten Richtung. void transition(Symbol symbol, Direction scrollDirection, long scrollDelay) Gleiche Funktion wie transition(Symbol), jedoch mit benutzerdefinierten zeitlichen Abständen in Millisekunden zwischen dem Scrollen. void draw(Consumer\u0026lt;Graphics2D\u0026gt; drawer) Ruft die übergebene Lambda-Funktion mit einem Graphics2D Kontext auf, so dass ein Bild gezeichnet werden kann. Dieses wird anschliessend sofort auf der Anzeige dargestellt. void draw(BufferedImage image) Gibt das übergebene BufferedImage auf der Anzeige aus. Dieses muss den Typ TYPE_BYTE_BINARY (1bit Farbtiefe = nur schwarz/weiss) sowie eine Grösse von 8x8 Pixeln aufweisen. void draw(BufferedImage image, int x, int y) Gleiche Funktion wie BufferedImage, jedoch kann hier auch ein grösseres Bild angegeben werden, da automatisch ein Ausschnitt von 8x8 Pixeln ab der genannten X/Y Position erzeugt wird. Enumerationen com.pi4j.crowpi.components.LedMatrixComponent Javadoc enthält alle unterstützten Symbole welche von dieser Komponenten-Klasse dargestellt werden können. Es handelt sich hierbei um alle ASCII-Codes von 32 bis 127 sowie diversen Symbolen wie beispielsweise HEART für ein Herz. Die Werte sind jeweils als byte[] Array hinterlegt, was der internen Darstellung der LED Matrix Anzeige entspricht. Jedes Element ist eine Zeile und die Bits 0-7 entsprechen den jeweiligen Spalten in umgekehrter Reihenfolge, sprich das Bit 7 stellt die Spalte an der X-Position 0 dar. Beispielapplikation Die nachfolgende Beispielapplikation zeigt nacheinander 4 verschiedene Beispiele für die LED Matrix, um dessen Vielfältigkeit und die verschiedenen zur Verfügung gestellten Funktionen dieser Bibliothek zu demonstrieren. Zuerst wird die Komponente initialisiert, mit der Funktion setEnabled aktiviert und eine mittlere Helligkeit mit setBrightness konfiguriert.\nDas erste Beispiel zeigt nun die Verwendung von draw(Consumer\u0026lt;Graphics2D\u0026gt;) mit einer anonymen Lambda-Funktion. Dies klingt zuerst kompliziert, jedoch ist dies nichts anderes als die Möglichkeit eine eigene Funktion zu übergeben, um darin beliebige Zeichenoperationen durchzuführen. Der Parameter graphics entspricht dabei der Standard-Klasse java.awt.Graphics2D, wofür sich im Internet weitere Dokumentation finden lassen. Hier wird nun ein Kreuz gezeichnet (zuerst eine Linie von oben-links nach unten-rechts, dann von oben-rechts nach unten-links) und anschliessend ein Kreis darüber. Das Resultat wird dann auf der LED Matrix dargestellt.\nDas zweite Beispiel zeigt nach einer kurzen Pause eine Schleife über eine Liste von vordefinierten Symbolen, in diesem Fall vier verschiedenen Smileys. Diese werden jeweils mit einer kurzen Pause nacheinander dargestellt und demonstrieren somit einige der vordefinierten Symbole. In der Enumeration LedMatrixComponent.Symbol lassen sich noch weitere Symbole zur freien Verwendung finden. Konkret wird mit der for-Schleife über das Array von Symbolen iteriert und jedes wird nacheinander mit print sofort angezeigt.\nDas dritte Beispiel zeigt ebenfalls vier verschiedene Symbole, dieses Mal jedoch unter Verwendung der transition Methode. Diese ersetzt den Inhalt der LED Matrix nicht sofort, sondern schiebt das neue Symbol mit der gewünschten Richtung in die Anzeige rein. Wird also zum Beispiel Direction.UP gewählt, so wird das neue Symbol von unten nach oben in die Anzeige reingeschoben.\nDas vierte Beispiel gibt schliesslich einen längeren Text aus. Die Methode print stellt diesen automatisch so dar, dass nacheinander alle Zeichen auf der Anzeige mit Scroll-Effekt dargestellt werden. Intern wird hierfür ebenfalls die transition Methode vom vorherigen Beispiel genutzt. Um die print Methode zusammen mit Symbolen zu nutzen, können beliebig viele Symbole mit dem Muster {NAME} eingebunden werden, sprich {HEART} wird durch das eigentliche HEART Zeichen von LedMatrixComponent.Symbol ersetzt.\nBevor die Applikation endet, wird die LED Matrix ordnungsgemäss mit setEnabled deaktiviert.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/LedMatrixApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.LedMatrixComponent; import com.pi4j.crowpi.components.LedMatrixComponent.Symbol; import com.pi4j.crowpi.components.definitions.Direction; /** * Demonstrates the countless abilities of the 8x8 LED matrix by showing multiple demo examples one after another. */ public class LedMatrixApp implements Application { @Override public void execute(Context pi4j) { // Initialize and enable LED matrix with medium brightness final var matrix = new LedMatrixComponent(pi4j); matrix.setEnabled(true); matrix.setBrightness(7); // Draw a cross with a circle over it using a Graphics2D lambda function // Further commands for Graphics2D can be found in the official Java documentation // This can be adjusted to draw your own symbols and images on the LED matrix matrix.draw(graphics -\u0026gt; { graphics.drawLine(0, 0, 7, 7); graphics.drawLine(7, 0, 0, 7); graphics.drawOval(1, 1, 5, 5); }); // Sleep for a second before moving to the next example... sleep(1000); // Display list of smiley symbols with a short delay between each one final var symbols = new Symbol[]{ Symbol.SMILEY_HAPPY, Symbol.SMILEY_SAD, Symbol.SMILEY_NEUTRAL, Symbol.SMILEY_SHOCKED }; for (Symbol symbol : symbols) { matrix.print(symbol); sleep(1000); } // Transition to all four arrows with each sliding in from the direction its pointing towards matrix.transition(Symbol.ARROW_UP, Direction.UP); matrix.transition(Symbol.ARROW_DOWN, Direction.DOWN); matrix.transition(Symbol.ARROW_LEFT, Direction.LEFT); matrix.transition(Symbol.ARROW_RIGHT, Direction.RIGHT); // Print a long text which gets automatically scrolled across the LED matrix // Any text written between curly braces gets automatically looked up in the Symbol table // In this example, \u0026#34;{HEART}\u0026#34; will be replaced with the actual \u0026#34;Symbol.HEART\u0026#34; value // If such a pattern exists but no symbol is found with that name, it gets ignored and printed as-is. matrix.print(\u0026#34;CrowPi + Pi4J = {HEART}\u0026#34;); // Disable the LED matrix before exiting matrix.setEnabled(false); } } Weitere Möglichkeiten In Kombination mit dem Button könnten kleine Spiele wie Snake oder Pong gespielt werden.\nDas Beispiel könnte so verändert werden, dass auf der Standardeingabe ein Text entgegengenommen wird, welcher anschliessend mit print(String) auf der Anzeige ausgegeben wird.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/light-sensor/","title":"Lichtsensor","tags":["i2c"],"description":"","content":"Funktionsweise Der Lichtsensor nutzt photoelektronische Effekte, um Lichteinstrahlung in ein elektrisches Signal zu wandeln. Dieses Signal kann mittels Elektronik so skaliert werden, dass ein Messwert in der Einheit Lux entsteht. Beim CrowPi wird dazu der Umgebungslichtsensor BH1750 verwendet. Dieser arbeitet mit einer Photodiode. Zusätzlich erlaubt der verwendete Sensor eine Konfiguration der Messgenauigkeit. Er kann mit 3 verschiedenen Auflösungen betrieben werden. Diese sind: 0.5 Lux, 1 Lux oder 4 Lux. Die Zeit, die für eine Messung benötigt wird, schwankt dabei massiv. Bei einer Auflösung von 4 Lux werden typischerweise 16 Millisekunden benötigt. Bei einer Auflösung 0.5 Lux hingegen bereits 120 Millisekunden. Diese Zeit ist natürlich auch bei der Programmierung des Sensors zu beachten. Zu schnelle Lesevorgänge können zu ungültigen Messwerten führen.\nAngesteuert wird der Lichtsensor BH1750 mittels des Bus I2C. Näheres zu diesem Bus kann unter Hardware I2C nachgeschlagen werden. Obwohl der Sensor nur wenige Einstellmöglichkeiten bietet, sind die Kombinationsmöglichkeiten eines Lichtsensors beinahe unendlich. Es gibt viele mögliche Szenarien, wie der Sensor eingesetzt werden kann.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.LightSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung LightSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Lichtsensor mit der Standard Bus- und Geräteadresse. LightSensorComponent(com.pi4j.context.Context pi4j, int address) Initialisiert einen Lichtsensor mit einer benutzerdefinierten Bus- und Geräteadresse. Methoden Methode Bemerkung double readLight() Liest einmalig die Helligkeit aus dem Lichtsensor. Es wird die Standardauflösung von 1 Lux genutzt. double readLight(int resolution) Liest einmalig die Helligkeit aus dem Lichtsensor. Es können 3 verschiedene Auflösungen benutzt werden. Die gewünschte Auflösung wird als Integer gemäss folgender Definition übergeben: 0 = 4 Lux / 1 = 1 Lux / 2 = 0.5 Lux. Beispielapplikation Die nachfolgende Beispielapplikation liest mit einem definierten Takt (DELAY) in Millisekunden den aktuellen Messwert des Lichtsensors aus. Die Anzahl gelesener Werte und somit die Ausführungsdauer des Programms kann mit NUMBER_OF_LOOPS definiert werden. Die Applikation läuft also genau DELAY mal NUMBER_OF_LOOPS Millisekunden. Mit den voreingestellten Werten wären das entsprechend exakt 20 Sekunden. Nachdem der Messwert eingelesen ist, wird er mit einer einfachen Logik zu Textausgaben verarbeitet. Nach diesem Prinzip könnte zum Beispiel eine Lampe automatisch ein- oder ausgeschaltet werden. Die Grenzwerte können dabei einfach über DARK_VALUE als unterer Schaltpunkt und BRIGHT_VALUE als oberer Schaltpunkt konfiguriert werden. Die Wiederholung der Messung und Ausgabe wird dabei durch einen for-loop umgesetzt. Zu beachten gilt speziell: Da der Sensor eine kleine Zeit für eine Messung benötigt kann eine zu kurze Taktrate zu ungültigen Messergebnissen führen. Weniger als 150 Millisekunden werden als Einstellung für DELAY nicht empfohlen. Pfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/LightSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.LightSensorComponent; /** * Measures the current illuminance with the CrowPi Light sensor and prints some outputs to the user. */ public class LightSensorApp implements Application { /** * Define a measurement interval in millis (to short interval can\u0026#39;t be handled by the sensor) */ private static final int DELAY = 1000; /** * Define a number of loops until the App shuts down */ private static final int NUMBER_OF_LOOPS = 20; /** * Define lower light limit to work with */ private static final double DARK_VALUE = 150; /** * Define upper light limit to work with */ private static final double BRIGHT_VALUE = 3000; @Override public void execute(Context pi4j) { // Initialize a new Light Sensor final var sensor = new LightSensorComponent(pi4j); // Start the measurements: System.out.println(\u0026#34;Starting new measurements ...\u0026#34;); // Loop until number of loops is reached for (int i = 0; i \u0026lt; NUMBER_OF_LOOPS; i++) { // Read the current illumination from sensor double value = sensor.readLight(2); // Analyze measured value and react accordingly if (value \u0026lt; DARK_VALUE) { System.out.println(\u0026#34;Whoo that\u0026#39;s dark... You should turn on light\u0026#34;); } else if (value \u0026gt;= DARK_VALUE \u0026amp;\u0026amp; value \u0026lt; BRIGHT_VALUE) { System.out.println(\u0026#34;I feel good. Very nice light in here!\u0026#34;); } else if (value \u0026gt;= BRIGHT_VALUE) { System.out.println(\u0026#34;Oh no .. it\u0026#39;s so bright ... please ... please turn off the light\u0026#34;); } // Sleep before continuing with next measurement sleep(DELAY); } } } Weitere Möglichkeiten "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/pir-motion-sensor/","title":"PIR Motion Sensor","tags":["gpio"],"description":"","content":"Funktionsweise Beim PIR Motion Sensor handelt es sich um einen Bewegungssensor, der mit passivem Infrarot arbeitet. Diese Komponente nutzt einen pyroelektrischen Sensor, welcher Infrarot-Strahlung erkennen kann. Da jedes Lebewesen und Objekt abhängig von seiner jeweiligen Temperatur eine unterschiedliche Menge an Infrarot-Strahlen emittiert, ist der Sensor in der Lage diese zu erkennen.\nUm nun jedoch nicht das Grundrauschen zu messen, sondern effektiv Bewegung zu erkennen, ist der Sensor in zwei Hälften aufgeteilt, welche sich gegenseitig bei Stillstand wieder aufheben. Findet nun aber eine Bewegung statt, sehen die beiden Hälften unterschiedlich viel Strahlung, was anschliessend per GPIO an den Raspberry Pi als erkannte Bewegung übermittelt werden kann.\nMit dieser Komponente lässt sich zwar nicht feststellen wie viele Personen in der Nähe sind oder wie nahe sich diese am Sensor befinden, jedoch ist die vorhandene Funktionalität meist ausreichend. Somit finden Bewegungssensoren von diesem Typ auch oft Verwendung im Alltag, zum Beispiel für Aussenbeleuchtungen, die automatisch eingeschaltet werden sollen.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.PirMotionSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung PirMotionSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen PIR Motion Sensor mit dem Standard-Pin für den CrowPi. PirMotionSensorComponent(com.pi4j.context.Context pi4j, int address) Initialisiert einen PIR Motion Sensor mit einem benutzerdefinierten Pin. Methoden Methode Bemerkung MotionState getState() Gibt den aktuellen Zustand vom PIR Motion Sensor zurück. boolean hasMovement() Überprüft ob der PIR Motion Sensor zurzeit Bewegung erkennt. boolean hasStillstand() Überprüft ob der PIR Motion Sensor zurzeit Stillstand erkennt. void onMovement(SimpleEventHandler handler) Setzt den Event Handler welcher bei erkannter Bewegung aufgerufen werden soll. null deaktiviert diesen Event Listener. void onStillstand(SimpleEventHandler handler) Setzt den Event Handler welcher bei erkanntem Stillstand aufgerufen werden soll. null deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.PirMotionSensorComponent Javadoc enthält alle möglichen Zustände, die vom PIR Motion Sensor zurückgegeben werden können. Beispielapplikation Die nachfolgende Beispielapplikation stellt eine vereinfachte Alarmanlage dar, die zuerst darauf wartet, dass der Sensor keine Bewegung mehr erkennt. Hierfür wird eine endlose while-Schleife verwendet, die zwischen jeder Überprüfung zuerst eine Sekunde wartet, um nicht unnötige Rechenlast zu erzeugen.\nAnschliessend wird die Alarmanlage aktiviert und überwacht für 30 Sekunden sämtliche auftretenden Zustandsänderungen vom Bewegungssensor. Hierfür werden die Funktionen onMovement() und onStillstand() benötigt, welche Event Handler zur Protokollierung von Änderungen registrieren. Nach 30 Sekunden wird die Anwendung automatisch beendet.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/PirMotionSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.PirMotionSensorComponent; import java.time.LocalDateTime; /** * Waits for the motion sensor to report stillstand before activating a simple alarm system for 30 seconds. Whenever the state of the * motion sensor changes, an alarm or recovery message with the current timestamp will be printed on the console. */ public class PirMotionSensorApp implements Application { @Override public void execute(Context pi4j) { // Create new PIR motion sensor component final var motionSensor = new PirMotionSensorComponent(pi4j); // Wait for stillstand before activating alarm system while (!motionSensor.hasStillstand()) { System.out.println(\u0026#34;Waiting for motion sensor to detect stillstand...\u0026#34;); sleep(1000); } System.out.println(\u0026#34;Alarm system activated, watching for movement...\u0026#34;); // Register event listeners to react to movement and stillstand // Those will be asynchronously called and do not block the application itself motionSensor.onMovement(() -\u0026gt; { final var timestamp = LocalDateTime.now(); System.out.printf(\u0026#34;[%s] ALARM - Movement has been detected\\n\u0026#34;, timestamp); }); motionSensor.onStillstand(() -\u0026gt; { final var timestamp = LocalDateTime.now(); System.out.printf(\u0026#34;[%s] RECOVERY - No more movement detected\\n\u0026#34;, timestamp); }); // Wait 30 seconds before exiting this application for (int i = 30; i \u0026gt; 0; i--) { System.out.println(\u0026#34;Waiting for \u0026#34; + i + \u0026#34; second(s) before exiting...\u0026#34;); sleep(1000); } // Cleanup the event listeners before exiting motionSensor.onMovement(null); motionSensor.onStillstand(null); } } Weitere Möglichkeiten Das Beispiel mit dem Buzzer kombinieren, um einen Alarmton abzuspielen, wenn der Zustand von STILLSTAND auf MOVEMENT ändert. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/pwm/","title":"Pulse Width Modulation (PWM)","tags":["pwm"],"description":"","content":"Das Wichtigste in Kürze Die Abkürzung PWM steht für Pulse Width Modulation und wird im Deutschen auch oft als Pulsbreitenmodulation oder Pulsweitenmodulation bezeichnet. Diese Technik wird unter anderem für die Steuerung von Servomotoren eingesetzt und findet beispielsweise auch Verwendung bei den Lüftern von einem regulären Computer.\nMit PWM ist es möglich, eine Komponente wie einen Motor nicht nur mehr rein binär zu steuern, sprich aus (0% Leistung) oder ein (100% Leistung), sondern diese fast beliebig zu steuern. Die Funktionsweise von PWM funktioniert hierbei so, dass die Komponente in einem bestimmten Zeitraum immer wieder aus- und angeschaltet wird.\nEin gutes Beispiel hierfür ist beim CrowPi die Buzzer-Komponente, welche über einen digitalen Anschluss verfügt und eigentlich nur einen einzigen Ton abspielen kann. Um damit nun trotzdem Melodien wie im verlinkten Beispiel zu erzeugen, wird der Buzzer mit PWM für die gewünschte Tonfrequenz konfiguriert und schaltet sich so beispielsweise bei der Note C7 insgesamt 2093x pro Sekunde aus und wieder an, was somit von uns als C7 wahrgenommen wird.\nSoftware vs. Hardware Auf dem Raspberry Pi und somit auch dem CrowPi stehen zwei verschiedene Arten von PWM zur Verfügung, konkret eine Software- sowie eine Hardware-Implementation. Beide bieten grundsätzlich die gleichen Möglichkeiten, jedoch können mit der Software-Version keine präzisen oder besonders schnellen Frequenzen erreicht werden.\nDer Grund dafür ist, dass bei der Software-Implementation für jeden einzelnen Zyklus (ein/aus) wieder ein erneuter Steuerbefehl von der JVM (Java Virtual Machine) bis zur entsprechenden Komponente übertragen werden muss, während bei der Hardware-Implementation der Raspberry Pi sich die gewünschte Frequenz merkt und diese selbstständig direkt auf der Platine regelt.\nTechnische Implementation Zur technischen Ansteuerung einer Komponente mit PWM müssen zweit Werte definiert werden:\nPuls-Pause-Verhältnis (englisch: Duty Cycle): Dieser Wert definiert das Verhältnis zwischen dem ein- und ausgeschalteten Zustand und wird durch eine Zahl zwischen 0% und 100% repräsentiert. Ein Wert von 50% bedeutet, dass innerhalb von einem Zyklus exakt die Hälfte der Zeit die Komponente ein- und anschliessend ausgeschaltet ist. Ein Wert von 25% hingegen würde bedeuten, dass nur ein Viertel der Zeit die Komponente eingeschaltet ist und die restlichen drei Viertel vom Zyklus die Komponente im ausgeschalteten Zustand verweilt.\nFrequenz (englisch: Frequency): Dieser Wert definiert wie oft pro Sekunde ein Zyklus (an/aus) fur diese Komponente stattfindet und wird üblicherweise in der Einheit Hertz (Hz) angegeben. Bei einem Wert von 10Hz würde die Komponente somit 10x zwischen dem ein- und ausgeschalteten Zustand in einer Sekunde alternieren.\nDiese beiden Werte lassen sich über die Pi4J-Bibliothek steuern und werden auch von diesem Projekt intern verwendet.\nWeitere Informationen Wikipedia zu PWM Wikipedia mit Tonfrequenzen "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/tags/pwm/","title":"pwm","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/relay/","title":"Relais","tags":["gpio"],"description":"","content":"Funktionsweise Das Relais ist eine Komponente, welche es ermöglichen soll mit geringen Schaltströmen grosse Lasten zu schalten. So kann beispielsweise mit dem Raspberry Pi eine grosse Lampe geschaltet werden, ohne den Raspberry Pi zu beschädigen. Um eine Last zu verkabeln, stellt das Relais drei Anschlüsse zur Verfügung. Diese sind beim CrowPi mit ´NC, NO, COM´ beschriftet. Die Anschlüsse für die Ansteuerung durch den CrowPi sind wie auch bei den anderen Komponenten bereits fertig verkabelt.\nAuf dem Schaltbild des Relais ist sehr gut zu erkennen, wie das Relais zu benutzen ist. Dabei stellt das Schaltsymbol immer den stromlosen Zustand einer Komponente dar. Also der digitale Ausgang im Status LOW ist.\nAuf dem Bild stellt das Rechteck die Spule des Relais dar. Wenn die Spule unter Strom gesetzt wird, bewegt sich der Kontakt entsprechend auf die andere Position. So kann ein Stromkreis jeweils zwischen COM - NC oder COM - NO geschlossen werden.\nBeim im CrowPi verbauten Relais handelt es sich um ein 24VDC/3A oder 120VAC/3A Produkt. Diese technische Spezifikation ist zwingend zu beachten. Überlastung des Relais kann den CrowPi beschädigen. Es besteht Brandgefahr!\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.RelayComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung RelayComponent(com.pi4j.context.Context pi4j) Initialisiert ein Relais mit dem Standard-Pin für den CrowPi. RelayComponent(com.pi4j.context.Context pi4j, int address) Initialisiert eine Relais mit einem benutzerdefinierten Pin. Methoden Methode Bemerkung void setStateOn() Schaltet das Relais ein. void setStateOff() Schaltet das Relais aus. boolean toggleState() Wechselt den Zustand des Relais abhängigen vom aktuellen Zustand. Gibt den neuen Zustand als boolean zurück. void setState(boolean on) Setzt den aktuellen Zustand des Relais auf den Wert des boolean on. Beispielapplikation Die Beispielapplikation initialisiert kurz das Relais. Danach wird es einige Male hin und her geschaltet, um das Toggle zu demonstrieren. Alles in allem eine kurze und kompakte Anwendung. Die Herausforderung bei einem Relais liegt mehr in der richtigen Verkabelung als in der Software.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/RelayApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.RelayComponent; /** * This example shows how to use the relay component by creating a clock-like sound by repeatedly toggling the relay on and off. */ public class RelayApp implements Application { @Override public void execute(Context pi4j) { // Create a new RelayComponent with default Pin RelayComponent relay = new RelayComponent(pi4j); // Turn on the relay to have a defined state relay.setStateOn(); sleep(1000); // Make a clock alike sound by toggle the relay every second once for (int i = 0; i \u0026lt; 10; i++) { System.out.println(relay.toggleState()); sleep(1000); } // That\u0026#39;s all so turn off the relay and quit relay.setStateOff(); System.out.println(\u0026#34;off\u0026#34;); sleep(2000); } } Weitere Möglichkeiten Eine eigene Komponente wie einen kleinen PC Lüfter oder ähnliches korrekt an das Relais verkabeln und dann eine Steuerung davon programmieren. Eine LED korrekt verkabeln und mit dem Lichtsensor kombinieren, damit diese sich bei Dunkelheit automatisch einschaltet. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/rfid/","title":"RFID","tags":["spi"],"description":"","content":"Funktionsweise Bei RFID, abgekürzt für Radio Frequency Identification, handelt es sich um eine Technologie, die es ermöglicht automatisch und kontaktlos mit einer Karte entsprechende Informationen auszutauschen. Dies wird zum Beispiel bei weit bekannten NFC Tags verwendet, jedoch auch für Anwendungen wie das kontaktlose Zahlen per Kreditkarte.\nEin grosser Vorteil ist hierbei, dass die jeweiligen Karten/Tags, auch Transponder genannt, so klein wie ein Reiskorn sein können und keine eigene Stromversorgung benötigen. Im CrowPi ist die Komponente MFRC522 verbaut, welche ein hochfrequentes elektronisches Wechselfeld bei 13.56 MHz erzeugt, um damit einerseits die Karte mit Strom zu versorgen und andererseits mit dieser zu kommunizieren. Somit können beispielsweise die beiden beigelegten Tags des CrowPi ausgelesen und beschrieben werden. Dies funktioniert dabei mit beliebigen Daten.\nDie Technologie dahinter ist sehr komplex und die entsprechenden Informationen dazu sind auf mehrere Standards aufgeteilt, hauptsächlich ISO-14443 für den allgemeinen Aufbau und die Kommunikation, sowie die entsprechenden Spezifikationen von NXP Semiconductors, dem Hersteller des Lese- und Schreibgeräts, sowie von den meisten RFID Karten. Die Einhaltung dieser Standards ist hierbei sehr wichtig, da eine RFID Karte bei falschen Schreiboperationen auch permanent beschädigt werden kann. Im Fachjargon wird das Lese- und Schreibgerät \u0026ldquo;Proximity Coupling Device\u0026rdquo; (PCD) genannt, während die verschiedenen Karten \u0026ldquo;Proximity Integrated Circuit Card\u0026rdquo; (PICC) heissen.\nEs besteht hier jedoch kein Grund zur Sorge, da sich diese Komponente um all die komplexen Aufgaben im Hintergrund kümmert und eine einfache sowie zuverlässige Schnittstelle bietet, um mit solchen RFID Karten zu interagieren. So bietet RfidComponent die Möglichkeit an, Karten zu erkennen und ein beliebiges Java-Objekt darauf zu speichern oder wieder zu lesen.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.RfidComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung RfidComponent(com.pi4j.context.Context pi4j) Initialisiert einen RFID Reader/Writer mit der Standard Reset-Pin und SPI Adresse sowie SPI Bandbreite für den CrowPi. RfidComponent(com.pi4j.context.Context pi4j, int spiChannel, int spiBaud) Initialisiert einen RFID Reader/Writer mit einer benutzerdefinierten SPI Adresse und Bandbreite ohne Reset-Pin. RfidComponent(com.pi4j.context.Context pi4j, Integer gpioResetPin, int spiChannel, int spiBaud) Initialisiert einen RFID Reader/Writer mit einem benutzerdefinierten Reset-Pin, SPI-Adresse sowie Bandbreite. Methoden Methode Bemerkung boolean isNewCardPresent() Gibt einen boolschen Wert zurück, ob eine neue Karte erkannt wurde, welche noch nicht gelesen wurde. boolean isAnyCardPresent() Gibt einen boolschen Wert zurück, ob irgendeine Karte erkannt wurde. Diese Methode erkennt im Gegensatz zu isNewCardPresent() auch bereits gelesene Karten. RfidCard initializeCard() Erzeugt eine neue Instanz von RfidCard, welche anschliessend zur Interaktion mit der Karte verwendet werden kann. Erfordert dass isNewCardPresent oder isAnyCardPresent vorher aufgerufen wurde und true zurückgab. void uninitializeCard() Muss zwingend nach dem Abschliessen aller Aktionen mit einer Karte aufgerufen werden, um die Kommunikation mit der Karte sauber zu beenden und neue Karten erkennen zu können. void onCardDetected(EventHandler\u0026lt;RfidCard\u0026gt; handler) Definiert einen Event Handler, welcher jedes Mal aufgerufen wird wenn eine neue Karte erkennt wird. Als erster Parameter wird hierbei die erkannte Karte übergeben. void waitForNewCard(EventHandler\u0026lt;RfidCard\u0026gt; handler) Gleiche Funktionsweise wie onCardDetected, blockiert jedoch den aktuellen Thread und wartet bis eine neue Karte erkannt wird, um dann einmalig einen Handler aufzurufen. Diese Methode deaktiviert den aktuellen Event Listener für onCardDetected. void waitForAnyCard(EventHandler\u0026lt;RfidCard\u0026gt; handler) Gleiche Funktionsweise wie waitForNewCard, akzeptiert jedoch auch eine Karte welche bereits gelesen oder beschrieben wurde und führt auf dieser die Aktion durch. Diese Methode deaktiviert den aktuellen Event Listener für onCardDetected. void reset() Setzt die Komponente auf den Ausgangszustand zurück, was bei allfälligen Problemen Abhilfe schaffen kann. Normalerweise nicht erforderlich für den normalen Betrieb. Karten-Methoden Die Klasse com.pi4j.crowpi.components.internal.rfid.RfidCard Javadoc welche als Rückgabewert bei initializeCard() oder als Parameter bei den Event Handlern onCardDetected(), waitForNewCard() sowie waitForAnyCard verwendet wird, bietet verschiedene Methoden um mit der erkannten Karte zu interagieren. Wichtig zu beachten ist, dass nach Ausführung eines Event Handlers automatisch uninitializeCard() aufgerufen wird, sodass sich die erkannte Karte nicht weiter nutzen lässt.\nMethode Bemerkung String getSerial() Gibt die Seriennummer der aktuellen Karte als String zurück. int getCapacity() Gibt die maximale Kapazität der aktuellen Karte in Bytes zurück. void writeObject(Object data) Schreibt das übergebene Objekt in die Karte. Wird dieser Befehl mehrfach aufgerufen, so wird dieses jeweils überschrieben. Das Objekt muss das Interface Serializable implementieren. Wirft eine RfidException falls die Operation nicht erfolgreich war. Object readObject() Liest das auf der Karte gespeicherte Objekt aus und gibt dieses als generischen Object-Typ zurück. Wirft eine RfidException falls die Operation nicht erfolgreich war. T readObject(Class\u0026lt;T\u0026gt; type) Gleiche Funktionsweise wie readObject(), aber gibt das Objekt gleich mit dem gewünschten Typ zurück. Wurde zum Beispiel mit writeObject vorher ein Animal gespeichert, so gibt readObject(Animal.class) direkt die Animal-Instanz zurück. Beispielapplikation Die nachfolgende Beispielapplikation definiert eine Klasse namens Person, um von einer beliebigen Person den Vornamen und Nachnamen, die Adresse sowie das Geburtsdatum zusammen mit einer zufällig generierten ID zu speichern. Nun werden zuerst zwei Personen generiert und in den Variablen personA sowie personB gespeichert, welche beide über verschiedene Daten verfügen.\nAnschliessend wird mit der waitForNewCard Methode die Anwendung so lange blockiert, bis eine neue Karte vom RFID Gerät erkannt wurde. Sobald dies der Fall ist, wird die übergebene Funktion ausgeführt, welche die Instanz personA von der Person-Klasse auf der Karte mit writeObject speichert. Es kann jedes beliebige Java-Objekt gespeichert werden, solange dieses das Serializable mit implements Serializable implementiert. Hierbei gilt zu beachten, dass diese Methode eine RfidException werfen kann, welche abgefangen werden muss. Diese tritt auf, wenn die Karte nicht ordnungsgemäss beschrieben werden konnte.\nNachdem die erste Karte beschrieben wurde, wird der gleiche Prozess für die zweite Karte wiederholt. Da mit waitForNewCard grundsätzlich nur neue Karten erkannt werden und eine Karte nach erfolgter Interaktion in einen Schlafzustand geht, kann hier garantiert werden, dass nicht sofort die zweite Person auf die gleiche Karte geschrieben wird, sondern sich eine neue Karte annähern oder die bestehende Karte kurzfristig entfernt werden muss.\nSobald beide Karten beschrieben wurden, wird ein Event Handler mit onCardDetected registriert, welcher asynchron jedes Mal aufgerufen wird, wenn eine neue Karte erkannt wurde. Da der RFID-Standard ein Verfahren gegen Kollisionen besitzt, können sich sogar mehrere Karten gleichzeitig auf dem Lese- und Schreibgerät befinden. Bei jeder ermittelten Karte wird mit readObject(Person.class) versucht, eine vorher gespeicherte Instanz der Person-Klasse auszulesen und in die Variable person zu speichern. Wenn dies gelingt, so wird die Person auf der Konsole ausgegeben. Auch hier muss eine allfällige RfidException aufgefangen werden, welche zum Beispiel auftritt, wenn die Daten nicht gelesen werden können oder korrupt sind.\nNach der Registrierung des Event Handlers schläft die Applikation für 30 Sekunden, um genug Zeit zu geben, die zwei verwendeten Karten auszuprobieren. Nach Ablauf der Zeit wird der Event Handler wieder sauber entfernt und die Applikation beendet sich.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/RfidApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.RfidComponent; import com.pi4j.crowpi.components.exceptions.RfidException; import java.io.Serializable; import java.time.LocalDate; import java.util.UUID; /** * This example first waits for the user to approach two different RFID cards and writes a different instance of a {@link Person} class into * each card. After doing so, the application registers an event listener which reads any approached cards and outputs the read and * deserialized {@link Person} class. The example will then sleep for 30 seconds to give the user some time to test the two tags or approach * other tags before shutting down cleanly by de-registering the event listener. */ public class RfidApp implements Application { @Override public void execute(Context pi4j) { // Initialize RFID component final var rfid = new RfidComponent(pi4j); // Generate two persons which will be written to tags // Values taken from fakenamegenerator.com, these are not real identities :-) final var personA = new Person( \u0026#34;Robert\u0026#34;, \u0026#34;Parson\u0026#34;, \u0026#34;21 Southern Street, Bohemia, NY 11716\u0026#34;, LocalDate.of(1948, 2, 23) ); final var personB = new Person( \u0026#34;Lisa\u0026#34;, \u0026#34;Knee\u0026#34;, \u0026#34;1944 Veltri Drive, Old Harbor, AK 99643\u0026#34;, LocalDate.of(2000, 8, 11) ); // Wait for the user to approach a first card and write person A System.out.println(\u0026#34;Please approach a first card to write person A\u0026#34;); rfid.waitForNewCard(card -\u0026gt; { try { card.writeObject(personA); System.out.println(\u0026#34;Person A was written to card \u0026#34; + card.getSerial()); } catch (RfidException e) { System.out.println(\u0026#34;Could not write card for person A: \u0026#34; + e.getMessage()); } }); // Wait for the user to approach a second card and write person B System.out.println(\u0026#34;Please approach a second card to write person B\u0026#34;); rfid.waitForNewCard(card -\u0026gt; { try { card.writeObject(personB); System.out.println(\u0026#34;Person B was written to card \u0026#34; + card.getSerial()); } catch (RfidException e) { System.out.println(\u0026#34;Could not write card for person B: \u0026#34; + e.getMessage()); } }); // Register event listener to detect card in proximity rfid.onCardDetected(card -\u0026gt; { // Print serial number and capacity of approached card System.out.println(\u0026#34;Detected card with serial \u0026#34; + card.getSerial() + \u0026#34; and capacity of \u0026#34; + card.getCapacity() + \u0026#34; bytes\u0026#34;); // Read `Person` object from card and print it try { final var person = card.readObject(Person.class); System.out.println(\u0026#34;Read person from card: \u0026#34; + person); } catch (RfidException e) { System.out.println(\u0026#34;Could not read person from card: \u0026#34; + e.getMessage()); } }); // Sleep for 30 seconds to give the user some time to approach various cards System.out.println(\u0026#34;Waiting 30 seconds for new RFID cards, try switching between the previously written cards...\u0026#34;); sleep(30000); // Cleanup by unregistering the event handler rfid.onCardDetected(null); } /** * This class represents a person with a random unique identifier (UUID), first name, last name, address and date of birth. * There is no magic involved here, except the implementation of the {@link Serializable} interface which is needed. * You can read and write any kind of class from/to a RFID card as long as it is serializable. */ private static final class Person implements Serializable { private final UUID uuid; private final String firstName; private final String lastName; private final String address; private final LocalDate dateOfBirth; public Person(String firstName, String lastName, String address, LocalDate dateOfBirth) { // Generate a random UUID for this person this.uuid = UUID.randomUUID(); // Store all other attributes in this class this.firstName = firstName; this.lastName = lastName; this.address = address; this.dateOfBirth = dateOfBirth; } public UUID getUuid() { return uuid; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public String getAddress() { return address; } public LocalDate getDateOfBirth() { return dateOfBirth; } /** * Generate a nice description for this object when converted to a string which contains all attributes * * @return Human-readable string describing this person */ @Override public String toString() { return getUuid() + \u0026#34;: \u0026#34; + getFirstName() + \u0026#34; \u0026#34; + getLastName() + \u0026#34; @ \u0026#34; + getAddress() + \u0026#34;, born \u0026#34; + getDateOfBirth(); } } } Weitere Möglichkeiten Das Beispiel zu einer Art Zutrittskontrolle ausbauen und beispielsweise nur Personen mit einem bestimmten Attribut zulassen.\nBei der Erkennung von Personen könnte auf dem LCD Display ein kleiner Begrüssungstext angezeigt werden.\nStatt dem Speichern von Personen könnten auch andere Daten auf einer Karte abgelegt werden, zum Beispiel eine (nicht sehr sichere) Implementation einer Bank wo auf jeder Karte der Inhaber sowie der aktuelle Kontostand gespeichert wird. Hierfür wäre die Methode waitForAnyCard praktisch, um eine bereits aufgelegte Karte erneut zu beschreiben.\nZusätzliche Links NXP Semiconductors: ISO/IEC 14443 PICC Selection NXP Semiconductors: Spezifikation zu MFRC522 NXP Semiconductors: Spezifikation zu MIFARE Classic 1K "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/step-motor/","title":"Schrittmotor","tags":["gpio"],"description":"","content":"Funktionsweise Der Schrittmotor, bestehend aus festem Stator und bewegenden Rotor, erhält sein Drehmoment durch unterschiedlich ausgerichtete Magnetfelder. Der Rotor dreht sich dabei immer so, dass sich ein möglichst starker magnetischer Fluss ausbildet. Anders als bei anderen Motoren befinden sich beim Schrittmotor jedoch nur im Stator Spulen. Durch gezieltes Ein- und Ausschalten dieser Spulen wird der Motor in Drehung versetzt. Mit korrekter Abfolge der Steuerung lassen sich so Vorwärts und Rückwärtslauf implementieren. Der Name des Motors kommt aus der Tatsache das sich ebenfalls durch Steuerung der Spulen einzelne Schritte mit dem Motor bewegen lassen. Die Schrittgrösse ist dabei abhängig vom physikalischen Aufbau des Schrittmotors. Um die Position des Rotors zu bestimmen, genügt es, ausgehend von einer Ausgangslage die Schritte im bzw. gegen den Uhrzeigersinn zu zählen und mit dem Schrittwinkel zu multiplizieren.\nDie Schrittmotoren bieten folgende Vorteile:\nGenaue Positionierung, keine kumulierten Fehler Haltemoment in Ruhelage Günstige Antriebslösung mit hoher Genauigkeit Einfacher Aufbau des Treibers Voraussetzungen DIP Switches Für diese Komponente müssen vier DIP Switches des rechten Blockes gesetzt werden. Die Stellung der DIP Switches sollte anschliessend so aussehen:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.StepMotorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung StepMotorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Schrittmotor mit den Standardeinstellungen für den CrowPi. StepMotorComponent(com.pi4j.context.Context pi4j, int[] addresses, int[][] steps, long pulseMilliseconds) Initialisiert einen Schrittmotor mit frei wählbaren Pins. Diese werden mit dem Parameter steps an entsprechende Schritte des Motors gekoppelt. Zusätzlich kann noch die Pulslänge übergeben werden. Methoden Methode Bemerkung void turnDegrees(int degrees) Dreht die Achse des Schrittmotors um den übergebenen Winkel in Grad [°]. Ein negativer Winkel dreht den Motor rückwärts. void turnForward(int steps) Dreht den Motor um die spezifizierte Anzahl Schritte vorwärts. void turnBackward(int steps) Dreht den Motor um die spezifizierte Anzahl Schritte rückwärts. Beispielapplikation Die Beispielanwendung zeigt auf einfache Art und Weise wie die verschiedenen Methoden der StepMotorComponent zu verwenden sind. Zuerst wird nach einer kurzen Warnung der Motor um 50 Schritte vorwärts gedreht. Anschliessend dreht der Motor rückwärts ebenfalls um 50 Schritte. Der Motor ist also wieder in Ausgangsposition. Abschliessend wird nun mithilfe eines for-loops einige Male hin und her gedreht. Dazu wird nun die turnDegrees Methode verwendet.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/StepMotorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.StepMotorComponent; /** * This example shows how the step motor on the CrowPi can be used. It allows for precise rotation in either direction and requires the DIP * switches 3, 4, 5 and 6 on the right DIP switch to be set. Turning by either a given count or degrees is being demonstrated below. */ public class StepMotorApp implements Application { @Override public void execute(Context pi4j) { // Initialize step motor with default configuration for CrowPi final var stepMotor = new StepMotorComponent(pi4j); // \u0026#39;Warn\u0026#39; the user about the upcoming action System.out.println(\u0026#34;Watch your step motor closely, it will start moving in 5 seconds...\u0026#34;); sleep(5000); // Turn the motor 50 times forward and backward, resulting in the same position System.out.println(\u0026#34;Moving 50 steps forward...\u0026#34;); stepMotor.turnForward(50); sleep(1000); System.out.println(\u0026#34;...and moving 50 steps backward...\u0026#34;); stepMotor.turnBackward(50); System.out.println(\u0026#34;...and we are back at our previous position!\u0026#34;); sleep(1000); // Simulate a sweeping motion (forward -\u0026gt; backward + backward -\u0026gt; forward) for (int i = 5; i \u0026gt; 0; i--) { System.out.println(\u0026#34;Sweep sweep sweep... just \u0026#34; + i + \u0026#34; more times\u0026#34;); // Start by rotating 90 degrees forward... stepMotor.turnDegrees(90); // ...then rotating 180 degrees backwards to the other side... // note: a negative amount of degrees means going backward stepMotor.turnDegrees(-180); // ...then back to the center by going 90 degrees forward again stepMotor.turnDegrees(90); } } } Weitere Möglichkeiten Ein 3D-Drucker könnte aus der Kombination von mehreren Schrittmotoren gebaut werden.\nAutomatisches Heizventil in Kombination mit einem Temperatursensor.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/spi/","title":"Serial Peripheral Interface (SPI)","tags":["spi"],"description":"","content":"Das Wichtigste in Kürze Das Serial Peripheral Interface, abgekürzt SPI, ist ein Bus-System welches eine Kommunikation zwischen einem Hauptgerät (englisch als «Master» bezeichnet) und einem oder mehreren Nebengeräten (englisch als «Slave» bezeichnet) ermöglicht. Eine direkte Kommunikation zwischen allen Teilnehmern ist hierbei nicht möglich, viel mehr kann der Master jederzeit auswählen mit welchem Slave er Daten austauschen möchte.\nUm nur einen Slave anzusprechen werden insgesamt 3 Signalleitungen benötigt, wovon zwei für die bidirektionale Datenübertragung und eine als Taktgeber für die serielle Übertragung genutzt wird. Wenn weitere Slaves angesprochen werden sollen, so werden zusätzliche Signalleitungen je nach gewünschter Topologie benötigt.\nVerwendungen SPI wird neben der Kommunikation zwischen Mikrocontrollern auch für das Ansprechen zahlreicher Sensoren und Aktoren verwendet. Ähnlich wie bei I²C können hier über bereits 3 Leitungen eine grosse Anzahl von Steuerkommandos und Daten in beide Richtungen mit einer relativ hohen Taktrate übermittelt werden. Ein besonderer Vorteil ist hier auch die Unterstützung von «Full Duplex», also dem gleichzeitigen Übertragen von Daten in beide Richtungen.\nDie technische Implementation ist hierbei sehr einfach und wird beispielsweise auch zur Kommunikation mit SD-Karten verwendet. Auch der Nintendo Game Boy nutzte dieses Protokoll bereits zur Verbindung von mehreren Spielekonsolen über das Game Boy Link Cable.\nAdressierung Wie bereits im ersten Abschnitt erwähnt lassen sich auch bei SPI mehrere Slaves anschliessen. Die verfügbare Anzahl hängt hierbei von der jeweils verwendeten Hardware ab. Auf dem Raspberry Pi lässt sich standardmässig SPI0 mit zwei verschiedenen Slaves nutzen, was von den sogenannten Chip Select Pins gesteuert wird.\nWeitere Informationen Wikipedia SPI (Deutsch) Wikipedia SPI (Englisch mit weiteren Infos) SPI Pinout für Raspberry Pi "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/servo-motor/","title":"Servomotor","tags":["pwm"],"description":"","content":"Funktionsweise Servomotoren sind in einer Vielzahl von Bauformen und Grössen erhältlich. Eine Eigenschaft, welche einen Servomotor von einem normalen Elektromotor unterscheidet, ist die Existenz eines Regelkreises. Dieser Regelkreis ermöglicht also erst die Kontrolle über Drehgeschwindigkeit, Beschleunigung und Winkelposition des Motors. Im Gegensatz zum Schrittmotor sorgt nicht der physikalische Aufbau für diese Kontrollmöglichkeiten, sondern eine Regelung. Die Regelung im Falle des beim CrowPi beiliegenden Servomotors wird durch ein simples Potentiometer erreicht. Bei industriellen, hochwertigen Servomotoren werden für die Positionsrückmeldung spezielle Encoder verwendet. Diese erlauben deutlich höhere Genauigkeiten als die Bauform mit Potentiometer. Verwendet wird diese vereinfachte Form häufig im Modellbau für die Einstellung von Stellwinkeln bei Modellflugzeugen.\nDer Anschluss der Servomotors erfolgt so: Zum entfernen muss ein kleiner Hebel am Stecker gedrückt werden\nVoraussetzungen DIP Switches Für diese Komponente müssen zwei DIP Switches des rechten Blockes gesetzt werden. Die Stellung der DIP Switches sollte anschliessend so aussehen:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.StepMotorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung ServoMotorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Servomotor mit den Standardeinstellungen für den CrowPi. ServoMotorComponent(com.pi4j.context.Context pi4j, float minAngle, float maxAngle, float minDutyCycle, float maxDutyCycle) Initialisiert einen Servomotor mit dem Standardpin. Hier sind jedoch benutzerdefinierte Winkelangaben sowie Tastgrad einstellbar. ServoMotorComponent(com.pi4j.context.Context pi4j, int address, int frequency, float minAngle, float maxAngle, float minDutyCycle, float maxDutyCycle) Initialisiert einen Servomotor mit frei definierbarem Pin. Zusätzlich sind ebenfalls Winkelangaben sowie Tastgrad einstellbar. Methoden Methode Bemerkung void setAngle(float angle) Rotiert den Motor auf den übergebenen Winkel in Grad [°]. void setPercent(float percent) Positioniert den Motor zwischen minAngle und maxAngle prozentual. void moveOnRange(float value) Positioniert den Motor entsprechend des übergebenen Werts und anhand der Kalkulation aus den mit setRange gesetzten Grenzwerten. void moveOnRange(float value, float minValue, float maxValue) Positioniert den Motor entsprechend des übergebenen Werts und anhand der Kalkulation aus den mit angegeben Grenzwerten. Hat keinen Einfluss auf die mit setRange gesetzten Properties. void setRange(float minValue, float maxValue) Setzt die Unter- und Obergrenze der Werteskala. Wird für die Bewegungskalkulation mit moveOnRange(float value) benutzt. float getMaxAngle() Gibt den maximal positionierbaren Winkel des Servomotors zurück. float getMinAngle() Gibt den minimal positionierbaren Winkel des Servomotors zurück. Beispielapplikation Die Beispielanwendung zeigt auf einfache Art und Weise wie die verschiedenen Methoden der ServoMotorComponent zu verwenden sind. Als Erstes wird demonstriert, wie einfach mit der prozentualen Positionierung gearbeitet werden kann. Dazu wird die Methode setPercent verwendet. Als Zweites folgt dann ein Beispiel einer Positionierung mittels der Funktion setAngle, welche einen Winkel in Grad entgegennimmt. Zuletzt wird eine benutzerdefinierte Skalierung mit dem Beispiel einer Temperaturanzeige genutzt. Mittels setRange wird der Messbereich des Sensors einprogrammiert. Danach wird mit moveOnRange der Messwert in eine entsprechende Positionierung des Servomotors umgewandelt.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/ServoMotorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.ServoMotorComponent; /** * This example shows how the servo motor on the CrowPi can be used. It requires the right DIP switch to have 7 and 8 turned on and mainly * demonstrates the various ways of setting the servo position, namely either by percentage, angle in degrees or a custom value range. */ public class ServoMotorApp implements Application { @Override public void execute(Context pi4j) { // Initialize servo motor component final var servoMotor = new ServoMotorComponent(pi4j); // Demonstrate the percentage mapping on the servo System.out.println(\u0026#34;In 2 seconds, the servo motor will move to the left-most position which is 0%\u0026#34;); sleep(2000); servoMotor.setPercent(0); System.out.println(\u0026#34;In another 2 seconds, the servo motor will show 100% by moving to the right-most position\u0026#34;); sleep(2000); servoMotor.setPercent(100); System.out.println(\u0026#34;Last but not least, in 2 more seconds the servo will be centered to display 50%\u0026#34;); sleep(2000); servoMotor.setPercent(50); // Sweep once from left to right using the setAngle function System.out.println(\u0026#34;We will sweep once to the left in 2 seconds...\u0026#34;); sleep(2000); servoMotor.setAngle(-90); System.out.println(\u0026#34;... and now to the right in 2 more seconds!\u0026#34;); sleep(2000); servoMotor.setAngle(90); // Use a custom range for displaying the data System.out.println(\u0026#34;Imagine a pointer on the servo positioned above a label between -20ºC and +40ºC\u0026#34;); System.out.println(\u0026#34;By using the setRange() method, we can automatically map our temperature range to the servo range!\u0026#34;); System.out.println(\u0026#34;As an example, in five seconds the servo will show -10º which should be on the far left of the servo.\u0026#34;); sleep(2000); servoMotor.setRange(-20, +40); // This will define our range as values between -20 and +40 servoMotor.moveOnRange(-10); // This will map -10 based on the previously defined range // And this demo is over, sleep for a second to give the servo some time to position itself sleep(1000); } } Weitere Möglichkeiten Anzeige von Messerwerten mittels eines an der Achse montierten Zeigers. Zum Beispiel ein Thermometer "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/sound-sensor/","title":"Sound Sensor","tags":["gpio"],"description":"","content":" Funktionsweise Ein Sound Sensor funktioniert mittels eines Mikrofons. Die vom Mikrofon in elektrische Signale umgewandelten akustischen Schwingungen werden gegen einen Schwellenwert verglichen. Sobald die elektrischen Signale in ihrer Stärke einen gewissen Schwellwert übersteigen, wird am Sensor ein digitaler Ausgang geschaltet. Es wurde Lärm oder ein Geräusch erkannt.\nAm CrowPi kann dieser Schwellwert mittels eines Potentiometers eingestellt werden. Am einfachsten geht das, wenn man auf das entsprechende LED bei den Status LEDS achtet und den entsprechenden Lärm verursacht welcher erkannt werden soll. Wird das Potentiometer nach rechts gedreht, muss das entsprechende akustische Signal lauter sein, um vom Sensor erkannt zu werden. Auf die linke Seite gedreht wird der Sensor viel empfindlicher gegenüber leisen Geräuschen. Für den ersten Test am besten ganz nach rechts drehen. Zu finden ist das Potentiometer wie auf diesem Bild gezeigt: Voraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.SoundSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung SoundSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Sound Sensor mit dem Standard-Pin für den CrowPi. SoundSensorComponent(com.pi4j.context.Context pi4j, int address, long debounce) Initialisiert einen Sound Sensor mit einem benutzerdefinierten Pin. Zusätzlich kann mit debounce noch eine Entprellzeit in Mikrosekunden angegeben werden Methoden Methode Bemerkung boolean isNoisy() Gibt true zurück, wenn aktuell ein Geräusch vom Sensor erkannt wird boolean isSilent() Gibt true zurück, wenn aktuell Stille herrscht. SoundState getState() Gibt den aktuellen Zustand des Sensors in Form des SoundState zurück. void onNoise(SimpleEventHandler handler) Setzt den Event Handler, welcher bei auftretendem Lärm am Sensor aufgerufen werden soll. null deaktiviert diesen Event Listener. void onSilence(SimpleEventHandler handler) Setzt den Event Handler, welcher bei verschwundenem Lärm am Sensor aufgerufen werden soll. null deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.SoundSensorComponent Javadoc enthält alle möglichen Zustände welche vom Sound Sensor zurückgegeben werden können. Beispielapplikation Bei dieser Komponente wurde ein sehr simples Beispiel gewählt. Damit die Applikation jedoch richtig funktioniert, muss erst der Sound Sensor so eingestellt werden, dass ein Händeklatschen erkannt wird. Am besten wie in der Funktionsweise beschrieben kurz ausprobieren. Als erstes wird mit einer simplen Statusabfrage geprüft, ob gerade stille im Raum herrscht. Falls es gerade schon zu laut wäre, würde das Programm abbrechen. Ist es ruhig registriert das Programm einen onNoise Event Handler, welcher mittels einer Zählvariable zählt, wie oft schon Lärm erkannt wurde. Nach 3x Händeklatschen beendet die Applikation wieder. Für das Zählen in einer Lambdafunktion in Java muss ein spezieller Datentyp verwendet werden. Man sieht dies am AtomicInteger count. Der AtomicInteger ist eine spezielle Form eines normalen Integers, welcher jedoch auch innerhalb einer Lambdafunktion benutzt werden kann. Pfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/SoundSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.SoundSensorComponent; import java.util.concurrent.atomic.AtomicInteger; /** * A example application to show how the sound sensor could be used. It registers a event handler to the sensors and * the program loops until you clapped 3 times. */ public class SoundSensorApp implements Application { @Override public void execute(Context pi4j) { System.out.println(\u0026#34;Welcome to the SoundSensor Test\u0026#34;); // Initialize clap counting variable // There is a special kind of integer used because java lambda functions support only final variables final var count = new AtomicInteger(); // Initialize a SoundSensor component final var soundSensor = new SoundSensorComponent(pi4j); // If it is already noisy we can not run the clap example. You need to setup the potentiometer first. if (soundSensor.isNoisy()) { System.out.println(\u0026#34;It is already really noisy. Setup the potentiometer first\u0026#34;); return; } // Define how many times to clap final int CLAP_THRESHOLD = 3; // Ready to start the example so register the event handler which counts the number of claps. soundSensor.onNoise(() -\u0026gt; { final int currentCounter = count.incrementAndGet(); if (currentCounter \u0026lt; CLAP_THRESHOLD) { System.out.println(\u0026#34;You clapped! \u0026#34; + (CLAP_THRESHOLD - currentCounter) + \u0026#34; more times to finish\u0026#34;); } }); // Loop until clapped 3 times while (count.get() \u0026lt; CLAP_THRESHOLD) { sleep(10); } // Three times so application completed System.out.println(\u0026#34;Done\u0026#34;); // Clean the event handler soundSensor.onNoise(null); } } Weitere Möglichkeiten Mit der Relaiskomponente kombiniert könnte eine Lampe mittels Klatschen ein- und ausgeschaltet werden. Es könnte eine Alarmanlage gebaut werden, welche anhand von Lärm einen Eindringling erkennt. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/tags/spi/","title":"spi","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/hardware/steppermotor/","title":"Stepper Motor","tags":["spi"],"description":"","content":"Schrittmotoren bestehen aus mehreren Spulen, welche um die in ihrer Mitte liegenden Welle angeordnet sind. Die Welle wird von einem Zylinder umschlossen, welcher abwechselnd mit positiven und negativen Polen versehen ist. Sobald durch eine Spule Strom fliesst, erzeugt diese ein Magnetfeld, nach welchem sich die Pole im Zylinder der Welle ausrichten. Somit kann die Welle gedreht werden. Siehe auch Stepper Motor Control with the Raspberry Pi.\nStepper Motor unter Single Stepping\nBei den meisten Schrittmotoren kommt zusätzlich zur Welle noch ein Getriebe zum Einsatz, welches durch seine Übersetzung den Drehwinkel pro Schritt weiter verkleinert. Beim weit verbreiteten Stepper Motor 28BYJ-48 ist zum Beispiel ein 1/64 Getriebe verbaut. Jeder Schritt der Welle resultiert bei diesem Motor um eine um 64 verkleinerte Drehung.\nSiehe: DesignSpark: Stepper motors and drives, what is full step, half step and microstepping\nSingle Stepping Beim Single Stepping wird jeweils nur eine Spule im Gehäuse des Motors unter Strom gesetzt. Die Welle des Motors richtet sich also immer genau nach der momentan aktiven Spule aus.\nDouble Stepping Unter Verwendung des Double Stepping werden immer zwei Spulen simultan unter Strom gesetzt. Dies führt dazu, dass sich die Welle gemäss dem entstehenden Magnetfeld zwischen den zwei Spulen ausrichtet. Die sich überschneidenden Magnetfelder sind stärker als ein einzelnes Magnetfeld, weshalb der Schrittmotor unter diesem Modus mit grösserer Kraft arbeitet. Da allerdings zwei Spulen gleichzeitig mit Strom beliefert werden müssen, verdoppelt sich der Stromverbrauch im Vergleich zum Single Stepping.\nHalf Stepping Im Gegensatz zu den anderen Modi agiert Half Stepping in acht Schritten. Somit kann die Position des Motors genauer bestimmt werden als in den anderen Modi. Half Stepping kombiniert Single Stepping und Double Stepping. Dies führt dazu, dass der Motor nicht immer gleich viel Kraft hat. Bei jedem zweiten Schritt ist jeweils nur eine Spule aktiv.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/humi-temp-sensor/","title":"Temperatur- / Luftfeuchtigkeitssensor","tags":["gpio"],"description":"","content":"Funktionsweise Der im CrowPi verwendete DHT11 Temperatur- und Luftfeuchtigkeitssensor arbeitet für die Messung der Temperatur mit einem NTC-Temperatursensor. Dies ist ein temperaturabhängiger elektrischer Widerstand. Je nach Umgebungstemperatur leitet dieser den Strom besser oder schlechter. Diese Differenzen lassen sich messen und anhand von Referenzwerten kann die Temperatur ausgewertet werden. Das ist ein sehr einfaches Prinzip, welches häufig bei der Messung von Temperaturen zum Einsatz kommt. Für die Feuchtigkeit liegt zwischen zwei Elektroden ein spezielles Granulat. Je mehr Feuchtigkeit in diesem Granulat festgehalten wird, desto einfacher kann der Strom fliessen. Es ändert sich also auch hier der elektrische Widerstand. Die Übertragung der Messdaten erfolgt dann etwas speziell über einen einzelnen digitalen Ausgang am Sensor. Dieser wird in kurzen Pulsen im Mikrosekundenbereich angesteuert.\nJava mit Pi4J ist leider nicht in der Lage diese Pulse genügend schnell zu verarbeiten. Die Verzögerungen durch die vielen Schichten einer Applikation bis zur Hardware benötigen einfach zu viel Zeit. Deshalb wurde in diesem Beispiel ein Linux Treiber verwendet, welcher die Messwerte des Sensors in eine Datei schreibt. Diese wird von Java ausgelesen und so kann dennoch mit dem Sensor gearbeitet werden. Das ist keine optimale Lösung, aber sie ermöglicht immerhin die Arbeit mit dem Sensor innerhalb des CrowPi. Besser wäre eine separate Ansteuerung mittels eines Mikrocontrollers. Diese können aufgrund der Einfachheit ihres Aufbaus viel schneller auf die eingehenden Impulse reagieren und sind so in der Lage zuverlässigere Resultate als der Raspberry Pi zu liefern.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.HumiTempComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung HumiTempComponent() Initialisiert einen Temperatur- und Luftfeuchtigkeitssensor mit den Standardeinstellungen für den CrowPi. HumiTempComponent(int pollingDelayMs) Initialisiert einen Temperatur- und Luftfeuchtigkeitssensor mit den Standard Dateipfaden für den CrowPi. Die Polling-Zeit in welcher neue Sensordaten gelesen werden wird jedoch manuell überschrieben. HumiTempComponent(String humiPath, String tempPath, int pollingDelayMs) Initialisiert einen Temperatur- und Luftfeuchtigkeitssensor mit benutzerdefinierten Pfaden zu den Messwert Dateien. Die Polling-Zeit wird ebenfalls manuell überschrieben. Methoden Methode Bemerkung double getTemperature() Gibt den letzten Temperaturmesswert in °C zurück. double getHumidity() Gibt den letzten Luftfeuchtigkeitsmesswert in % zurück. Beispielapplikation Die sehr simple Beispielapplikation misst mithilfe eines for-loops einige Male die Temperatur und Luftfeuchtigkeit und gibt diese auf der Konsole aus. Verwendet werden dazu die Methoden getHumidity() und getTemperature() welche jeweils den aktuellen Messwert als double retournieren. Dieser Messwert könnte nun in weiteren Schritten wie gewünscht verarbeitet werden.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/HumiTempApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.HumiTempComponent; import com.pi4j.crowpi.components.SoundSensorComponent; /** * A simple demo application reading current temperature and humidity from the DHT11 sensor on the CrowPi */ public class HumiTempApp implements Application { @Override public void execute(Context pi4j) { // Initialize a HumiTempComponent with default values final var dht11 = new HumiTempComponent(); System.out.println(\u0026#34;Welcome to the HumiTempApp\u0026#34;); System.out.println(\u0026#34;Measurement starts now.. \u0026#34;); // Start some measurements in a loop for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;It is currently \u0026#34; + dht11.getTemperature() + \u0026#34;°C and the Humidity is \u0026#34; + dht11.getHumidity() + \u0026#34;%.\u0026#34;); sleep(2000); } } } Weitere Möglichkeiten Die gemessenen Werte könnten auf dem LCD Display angezeigt werden. "},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/tilt-sensor/","title":"Tilt Sensor","tags":["gpio"],"description":"","content":"Funktionsweise Ein Tilt Sensor, auf Deutsch Neigungs- oder Kippsensor, erkennt wenn dieser in eine bestimmte Richtung geneigt wird. Es existieren hier einige verschiedene Ausführungen, die Komponente auf dem CrowPi basiert jedoch auf einem SW-200D, welcher nur eine Richtung kennt und somit lediglich eine Neigung nach links (HIGH) oder rechts (LOW) erkennen kann.\nHierfür ist der silberne Draht auf der linken Seite der Komponente mit einer leitenden Innenhülle verbunden, in welcher sich zwei kleine Metallkugeln befinden. Innerhalb dieser Hülle ist auf der rechten Seite ein Kontaktpunkt vorhanden, welcher mit dem goldenen Draht auf der rechten Seite der Komponente verbunden ist. Abhängig von der Neigung berühren diese Kugeln nun den Kontaktpunkt oder eben nicht, sodass sich der aktuelle Zustand jeweils einfach via GPIO erkennen lässt.\nDiese Art von Sensor liefert somit zwar nicht viele Daten, wird aber trotzdem oft in der Robotik verwendet aufgrund der sehr einfachen Einsatzweise und dem niedrigen Stückpreis.\nVoraussetzungen DIP Switches Für diese Komponente muss der DIP Switch 2-2 aktiviert werden, da ansonsten der Tilt Sensor nicht mit dem CrowPi verbunden ist. Die Stellung der DIP Switches sollte anschliessend so aussehen:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.TiltSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung TiltSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Tilt Sensor mit dem Standard-Pin für den CrowPi. TiltSensorComponent(com.pi4j.context.Context pi4j, int address, long debounce) Initialisiert einen Tilt Sensor mit einem benutzerdefinierten Pin. Zusätzlich kann mit debounce noch eine Entprellzeit in Mikrosekunden angegeben werden. Methoden Methode Bemerkung TiltState getState() Gibt den aktuellen Zustand vom Tilt Sensor zurück. boolean hasLeftTilt() Überprüft ob der Tilt Sensor nach links geneigt ist. boolean hasRightTilt() Überprüft ob der Tilt Sensor nach rechts geneigt ist. void onTiltLeft(SimpleEventHandler handler) Setzt den Event Handler welcher beim Neigen nach Links aufgerufen werden soll. null deaktiviert diesen Event Listener. void onTiltRight(SimpleEventHandler handler) Setzt den Event Handler welcher beim Neigen nach Rechts aufgerufen werden soll. null deaktiviert diesen Event Listener. void onShake(SimpleEventHandler handler) Setzt den Event Handler welcher beim Schütteln, sprich 3x Zustandswechsel in kurzer Zeit, aufgerufen werden soll. null deaktiviert diesen Event Listener. void onShake(int threshold, SimpleEventHandler handler) Setzt den Event Handler welcher beim Schütteln aufgerufen werden soll. Der Parameter threshold definiert die Anzahl von Zustandswechseln. null als handler deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.TiltSensorComponent Javadoc enthält alle möglichen Zustände, welche vom Tilt Sensor zurückgegeben werden können. Beispielapplikation Die nachfolgende Beispielapplikation gibt zuerst den aktuellen Zustand des Tilt Sensors aus, welcher je nach Lage / Positionierung des CrowPi variieren kann. Danach werden zwei Event Listener mit onTiltLeft() bzw. onTiltRight() registriert, welche bei jedem Zustandswechsel des Sensors eine Nachricht auf die Konsole ausgibt. Somit wird nun eine Nachricht ausgegeben, wenn der CrowPi abwechslungsweise nach links oder rechts geneigt wird. Zudem wird noch ein Event Listener für onShake() registriert, welcher beim Schütteln des CrowPi eine spezielle Meldung ausgibt.\nDie Applikation wartet nun 20 Sekunden, um dem Anwender genug Zeit zu geben die Event Listener zu testen. Nach den 20 Sekunden werden die Event Listener wieder entfernt und die Applikation beendet sich. Das Entfernen der Event Listeners ist nicht explizit notwendig, da dies beim Beenden der JVM sowieso passiert, jedoch empfohlen.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/TiltSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.TiltSensorComponent; /** * Prints the initial state of the tilt sensor and then informs about further state changes. To do so, you can just tilt the CrowPi to the * left and right side. Please note that this component requires the DIP switch 2-2 to be enabled, otherwise this example will not work * properly. After 20 seconds the application will be automatically stopped. */ public class TiltSensorApp implements Application { @Override public void execute(Context pi4j) { // Create new tilt sensor component final var tiltSensor = new TiltSensorComponent(pi4j); // Print the current state of the tilt sensor System.out.println(\u0026#34;Current state of tilt sensor: \u0026#34; + tiltSensor.getState()); System.out.println(\u0026#34;Is the CrowPi tilted left: \u0026#34; + tiltSensor.hasLeftTilt()); System.out.println(\u0026#34;Is the CrowPi tilted right: \u0026#34; + tiltSensor.hasRightTilt()); // Register two event listeners to be notified when the tilt changes // These handlers will be asynchronously called and do not block the application itself tiltSensor.onTiltLeft(() -\u0026gt; System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt; Left Tilt \u0026lt;\u0026lt;\u0026lt;\u0026#34;)); tiltSensor.onTiltRight(() -\u0026gt; System.out.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt; Right Tilt \u0026gt;\u0026gt;\u0026gt;\u0026#34;)); // Register an additional event listener to detect shaking tiltSensor.onShake(() -\u0026gt; System.out.println(\u0026#34;!!! Shaking !!!\u0026#34;)); // Wait for 20 seconds before this application exits for (int i = 20; i \u0026gt; 0; i--) { System.out.println(\u0026#34;Waiting for \u0026#34; + i + \u0026#34; second(s) before exiting... Tilt your CrowPi before it is too late :-)\u0026#34;); sleep(1000); } // Cleanup by disabling the event listeners tiltSensor.onTiltLeft(null); tiltSensor.onTiltRight(null); tiltSensor.onShake(null); } } Weitere Möglichkeiten Das Beispiel um den Buzzer zu erweitern, sodass eine Alarmierung stattfindet, wenn der CrowPi in eine bestimmte Richtung geneigt ist.\nAutomatisch aktualisierende Darstellung der aktuellen Neigung auf der LED Matrix oder der LCD Anzeige.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/touch-sensor/","title":"Touch Sensor","tags":["gpio"],"description":"","content":"Funktionsweise Der Berührungssensor funktioniert im Wesentlichen wie jeder andere Knopf auch. Der Unterschied liegt darin das der Berührungs- oder Touch Sensor nicht gedrückt werden muss. Es reicht schon eine leichte Berührung, um den Sensor auszulösen. Dabei kennt der Sensor nur zwei Zustände. Er ist entweder gedrückt oder eben nicht. Dies entspricht im Programm einem HIGH oder LOW. Der Sensor erkennt die Berührung durch die Veränderung des elektrischen Widerstandes durch den Kontakt mit der Haut. Es gibt auch andere Varianten von Berührungserkennung. Diese sind jedoch viel komplexer und werden zum Beispiel in Mobiltelefonen eingesetzt.\nEine oft verwendete Funktion bei digitalen Eingängen ist die Entprellung. Dies bedeutet das nach jeder Statusänderung des Eingangs jeweils erst eine «Abkühlzeit» verstreichen muss. Solche Mehrfachauslösungen kommen fast bei jeder Art von Hardware-Knopf vor und sollten deshalb immer berücksichtigt werden. Wird die Entprellzeit zu kurz gewählt, kann es vorkommen, dass durch 1x Betätigen mehrere Events ausgelöst werden. Das wäre natürlich unerwünschtes Verhalten der Software.\nDie boolesche Verhaltensweise des Sensors macht die Benutzung während des Programmierens sehr einfach. Die Herausforderung liegt dabei meist mehr beim Gerüst rund um den Sensor herum. Zum Beispiel im Eventhandling, wenn der Knopf jederzeit funktionieren soll.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.TouchSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung TouchSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Touch Sensor mit dem Standard-Pin für den CrowPi. TouchSensorComponent(com.pi4j.context.Context pi4j, int address, long debounce) Initialisiert einen Touch Sensor mit einem benutzerdefinierten Pin. Zusätzlich kann mit debounce noch eine Entprellzeit in Mikrosekunden angegeben werden Methoden Methode Bemerkung boolean isTouched() Gibt true zurück falls der Berührungssensor gerade betätigt wird ansonsten false. TouchState getState() Gibt den aktuellen Zustand des Berührungssensor zurück. void onTouch() Setzt den Event Handler welcher beim Berühren des Sensors aufgerufen werden soll. null deaktiviert diesen Event Listener. void onRelease() Setzt den Event Handler welcher beim Loslassen des Sensors aufgerufen werden soll. null deaktiviert diesen Event Listener. Enumerationen com.pi4j.crowpi.components.TouchSensorComponent Javadoc enthält alle möglichen Zustände, die vom Touch Sensor zurückgegeben werden können. Beispielapplikation Die nachfolgende Beispielapplikation registriert zwei Event Listener auf dem Touch Sensor. Diese Listener lösen dann für 20 Sekunden jeweils ein minimales Event aus. Es wird jedes Mal in dieser Zeit wenn der Sensor berührt oder losgelassen wird ein kleiner Text mit dem Status ausgegeben. Nach Ablauf der Zeit werden die Listener wieder vom Berührungssensor entfernt und mittels der isTouched() Methode gewartet bis der Benutzer die Beispielapplikation beendet. Durch Verwendung des Konstruktors mit nur einem Argument wird in dieser Applikation die Standardeinstellung für die Entprellung benutzt. Diese liegt bei 10'000 Mikrosekunden und passt ganz gut für die meisten menschlichen Eingaben. Pfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/TouchSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.TouchSensorComponent; /** * Writes some Text output on Touch Sensor Events. After 20 seconds event handling is disable and the App waits for * termination by a final touch sensor press. */ public class TouchSensorApp implements Application { @Override public void execute(Context pi4j) { // create a touch sensor instance final var touchSensor = new TouchSensorComponent(pi4j); // create two listeners for detecting touch events touchSensor.onTouch(() -\u0026gt; System.out.println(\u0026#34;Seems like you are touching the sensor!\u0026#34;)); touchSensor.onRelease(() -\u0026gt; System.out.println(\u0026#34;You stopped touching the sensor!\u0026#34;)); // just any delay System.out.println(\u0026#34;Touch Sensor is now activated.\u0026#34;); for (int i = 20; i \u0026gt; 0; i--) { System.out.println(\u0026#34;Time until event listeners are killed: \u0026#34; + i + \u0026#34; seconds...\u0026#34;); sleep(1000); } // disable the event listeners we no longer need touchSensor.onTouch(null); touchSensor.onRelease(null); // end the program as soon as isTouched returns true System.out.println(\u0026#34;Press again to end this application\u0026#34;); while (!touchSensor.isTouched()) { sleep(10); } } } Weitere Möglichkeiten Das Beispiel um beliebige Abfolgen von Berührungen erweitern. So wäre zum Beispiel eine Kombination aus langen und kurzen Berührungen möglich um ein kleines Spiel zu entwickeln.\nUmsetzung des Morsealphabets mittels Touch Sensor und Events\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/ultrasonic-sensor/","title":"Ultraschall Distanzsensor","tags":["gpio"],"description":"","content":" Funktionsweise Der Ultraschall Distanzsensor misst mithilfe eines akustischen Signals die Distanz zu Objekten. Der Ton liegt dabei im Ultraschallbereich und ist für den Menschen nicht hörbar. Um das Signal von Umgebungsgeräuschen unterscheiden zu können, wird nicht ein langer Ton, sondern kurze pulsierendes Töne ausgeben. Beim im CrowPi verbauten Modell HC-SR04 handelt es sich dabei 8 einzelne Impulse auf einer Frequenz von 40kHz. Wenn diese Töne nun auf ein Objekt treffen, werden sie reflektiert und zurück Richtung Sensor geworfen. Sobald der Sensor seinen eigenen Ton wieder hört, schaltet er entsprechend seinen digitalen Ausgang. Zum Starten des Messvorgangs bietet der Sensor zusätzlich einen digitalen Eingang.\nWenn nun mit einem Programm die Zeit zwischen Aussenden des Tons (Trigger) und dem Wiedereintreffen des Tons gemessen wird, kann daraus mithilfe der Schallgeschwindigkeit die Distanz zum Objekt berechnet werden. Diese Funktion wird von der UltrasonicDistanceSensorComponent übernommen. Sie liefert direkt einen Messwert in Zentimetern.\nMit dem HC-SR04 können Distanzen zwischen 2 bis 3000 Zentimetern gemessen werden. Dabei ist mit einer Toleranz von etwa 3 Millimetern zu rechnen. Je nach Messdistanz variiert dieser Wert etwas. Genaueres dazu findet sich im Datenblatt des Sensors. Wichtig ist auch zu wissen, dass mehrere Ultraschallsensoren sich gegenseitig stören können. Weiter ist die Schallgeschwindigkeit von der Umgebungstemperatur abhängig. Die Messwerte können einige Prozent schwanken, wenn es kälter oder wärmer ist.\nVoraussetzungen DIP Switches Für diese Komponente werden keine spezifischen DIP-Switches benötigt, sodass diese in der Standardkonfiguration belassen werden können:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.UltrasonicDistanceSensorComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung UltrasonicDistanceSensorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Ultraschall Distanz Sensor mit dem Standard-Pin für den CrowPi. UltrasonicDistanceSensorComponent(com.pi4j.context.Context pi4j, int triggerAddress, int echoAddress) Initialisiert einen Ultraschall Distanz Sensor mit benutzerdefinierten Pins. Trigger ist dabei der digitale Eingang und Echo der Ausgang des Sensors. Methoden Methode Bemerkung double measure() Führt eine Messung aus und gibt die aktuelle Distanz [cm] zurück. Nutzt dabei die aktuelle Temperatureinstellung. double measure(double temperature) Führt eine Messung aus und gibt die aktuelle Distanz [cm] zurück. Bei der Distanzberechnung wird zudem der Einfluss der Umgebungstemperatur auf die Schallgeschwindigkeit berücksichtigt und kompensiert. void onObjectFound(SimpleEventHandler handler) Setzt den Event Handler, welcher bei Erkennung eines Objekts aufgerufen werden soll. null deaktiviert diesen Event Listener. void onObjectDisappeared(SimpleEventHandler handler) Setzt den Event Handler, welcher bei Verschwinden eines Objekts aufgerufen werden soll. null deaktiviert diesen Event Listener. void setMeasurementTemperature(double temperature) Definiert die Standardmesstemperatur, welche in die Distanzberechnung einbezogen wird. void setDetectionRange(double minRange, double maxRange) Definiert die Distanz welche gemessen werden muss, um als Objekt erkannt zu werden. Beispielapplikation Die nachfolgende Beispielapplikation führt als erstes unter Verwendung von onObjectFound eine Objekterkennung durch. Es wird jeweils ausgegeben, ob ein Objekt gefunden wurde und ebenfalls, wenn es wieder verschwunden ist. Danach werden einige Messwerte mit verschiedenen Temperatureinstellungen ausgegeben. So kann der Einfluss von Temperaturschwankungen auf den Messwert hervorragend analysiert werden. Anschliessend wird eine kurze for-Schleife gestartet welche jede Sekunde einen neuen Messwert ausgibt. Dies verschafft etwas Zeit, um auch einmal die Hand über den Sensor zu halten.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/UltrasonicDistanceSensorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.UltrasonicDistanceSensorComponent; import com.pi4j.crowpi.components.exceptions.MeasurementException; /** * Example Application of using the Crow Pi Ultrasonic Distance Sensor. */ public class UltrasonicDistanceSensorApp implements Application { @Override public void execute(Context pi4j) { // Create new tilt sensor component final var distanceSensor = new UltrasonicDistanceSensorComponent(pi4j); // Configures the Sensor to find Object passing in a predefined distance System.out.println(\u0026#34;Searching for an object now...\u0026#34;); distanceSensor.setDetectionRange(5,50); distanceSensor.setMeasurementTemperature(23); distanceSensor.onObjectFound(() -\u0026gt; System.out.println(\u0026#34;Sensor has found a Object in Range!\u0026#34;)); distanceSensor.onObjectDisappeared(() -\u0026gt; System.out.println(\u0026#34;Found Object disappeared!\u0026#34;)); sleep(10000); // Clean up event handlers System.out.println(\u0026#34;Searching completed.\u0026#34;); distanceSensor.onObjectFound(null); distanceSensor.onObjectDisappeared(null); // Just printing some text to the users System.out.println(\u0026#34;Let\u0026#39;s find out the impact of temperature to ultrasonic measurements!\u0026#34;); // Start a measurement with a temperature compensation like it is -10°C while measuring. double measurementCold = distanceSensor.measure(-10); System.out.println(\u0026#34;If you room has -10°C now we measure: \u0026#34; + measurementCold + \u0026#34; cm\u0026#34;); // Start a measurement with a temperature compensation like it is 30°C while measuring. double measurementHot = distanceSensor.measure(30); System.out.println(\u0026#34;If you room has 30°C now we measure: \u0026#34; + measurementHot + \u0026#34; cm\u0026#34;); System.out.format(\u0026#34;That\u0026#39;s a difference of %.2f %%. Only caused by the difference of sonics. Physic is \u0026#34; + \u0026#34;crazy\\n\u0026#34;, (measurementHot - measurementCold) / measurementCold * 100); System.out.println(\u0026#34;Lets now just measure for 10 Seconds. That gives some time to try the sensor a little.\u0026#34;); // Loop 10 times through the measurement. Print the result to the user for (int i = 0; i \u0026lt; 10; i++) { // Measures the current distance without temperature compensation and prints it to the user. try { System.out.println(\u0026#34;Measured distance is: \u0026#34; + distanceSensor.measure() + \u0026#34; cm\u0026#34;); } catch (MeasurementException e) { // If the measurement fails with a MeasurementException, we inform the user and try again next time System.out.println(\u0026#34;Oh no. Measurement failed... lets try again\u0026#34;); } // Delay the measurements a little. This gives you some time to move in front of the sensor. sleep(1000); } } } Weitere Möglichkeiten Das Beispiel um einen Temperatursensor erweitern, um immer korrekte Messwerte zu erhalten.\nJe näher etwas dem Sensor kommt, könnte der Buzzer schneller Piepen, ähnlich wie bei einer Einparkhilfe.\n"},{"uri":"https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/components/vibration-motor/","title":"Vibrationsmotor","tags":["gpio"],"description":"","content":"Funktionsweise Beim Vibrationsmotor handelt es sich um einen sehr kleinen Motor, der über eine kleine Unwucht verfügt. Durch diesen Fehler im Rundlauf entsteht die gewünschte Vibration. Aufgrund des elektrischen Anschlusses beim CrowPi ist jedoch nur ein Ein- und Ausschalten des Motors möglich. Theoretisch wäre aber auch PWM denkbar. Jedoch verfügt der verwendete Pin über keine PWM Funktionalität.\nVoraussetzungen DIP Switches Für diese Komponente muss einer der DIP-Switches auf die folgende Position eingestellt werden:\nON (links) 1 2 3 4 5 6 7 8 ON (rechts) 1 2 3 4 5 6 7 8 Verwendung Nachfolgend wird die Verwendung der Klasse com.pi4j.crowpi.components.RelayComponent Javadoc beschrieben.\nKonstruktoren Konstruktor Bemerkung VibrationMotorComponent(com.pi4j.context.Context pi4j) Initialisiert einen Vibrationsmotor mit dem Standard-Pin für den CrowPi. VibrationMotorComponent(com.pi4j.context.Context pi4j, int address) Initialisiert einen Vibrationsmotor mit einem benutzerdefinierten Pin. Methoden Methode Bemerkung void on() Schaltet den Vibrationsmotor ein. void off() Schaltet den Vibrationsmotor aus. boolean toggle() Wechselt den Zustand des Vibrationsmotors abhängig vom aktuellen Zustand. Gibt den neuen Zustand als boolean zurück. void pulse(int interval) Schaltet den Vibrationsmotor für die angegebene Zeit in Millisekunden ein. void setState(boolean on) Setzt den aktuellen Zustand des Vibrationsmotors auf den Wert des boolean on. Beispielapplikation Die Beispielapplikation führt erst einen kleinen Test mit Ein- und Ausschalten dem Vibrationsmotor durch. Anschliessend wird durch gezielte Variation der Pulslänge versucht einen möglichst nervigen Ton zu erstellen. Dadurch soll der Benutzer aufgeweckt werden, falls er vor dem PC eingeschlafen ist. Sobald der Benutzer das Aufwachen mit YES bestätigt wird die Applikation beendet.\nPfad zum Codebeispiel: src/main/java/com/pi4j/crowpi/applications/VibrationMotorApp.java Auf GitHub ansehen package com.pi4j.crowpi.applications; import com.pi4j.context.Context; import com.pi4j.crowpi.Application; import com.pi4j.crowpi.components.VibrationMotorComponent; import java.util.Scanner; /** * This example shows how to use the vibration motor. It basically represents a vibrating alarm clock which is going off and keeps making * noises until the user confirms being awake by writing `yes` to the console / standard input. Please note that this example requires the * DIP switch 2-1 to be activated for it to work. */ public class VibrationMotorApp implements Application { @Override public void execute(Context pi4j) { VibrationMotorComponent vibrationMotor = new VibrationMotorComponent(pi4j); // Short test if the component is working vibrationMotor.on(); sleep(500); vibrationMotor.off(); // Write to ask the user something System.out.println(\u0026#34;Are you awake? Answer with YES if you are...\u0026#34;); // Scanner is used to read the input from the commandline Scanner scanner = new Scanner(System.in); // Loops until YES is found while (!scanner.nextLine().equalsIgnoreCase(\u0026#34;YES\u0026#34;)) { // Do some pulses to create a strange noise for (int i = 10; i \u0026lt; 100; i++) { // As you see use pulse is a lot more comfortable than using .on -\u0026gt; sleep -\u0026gt; off vibrationMotor.pulse(i); sleep(i); } for (int i = 100; i \u0026gt; 10; i--) { vibrationMotor.pulse(i); sleep(i); } System.out.println(\u0026#34;Are you awake? Answer with YES if you are...\u0026#34;); } // User is awake, so we can turn off the vibration motor now. vibrationMotor.off(); } } Weitere Möglichkeiten In Kombination mit Knöpfen und Sensoren kann der Vibrationsmotor verwendet werden, um den Benutzer auf etwas aufmerksam zu machen. "}]